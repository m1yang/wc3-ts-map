/** @noSelfInFile **/



declare const bj_PI: number;
declare const bj_E: number;
declare const bj_CELLWIDTH: number;
declare const bj_CLIFFHEIGHT: number;
declare const bj_UNIT_FACING: number;
declare const bj_RADTODEG: number;
declare const bj_DEGTORAD: number;
declare const bj_TEXT_DELAY_QUEST: number;
declare const bj_TEXT_DELAY_QUESTUPDATE: number;
declare const bj_TEXT_DELAY_QUESTDONE: number;
declare const bj_TEXT_DELAY_QUESTFAILED: number;
declare const bj_TEXT_DELAY_QUESTREQUIREMENT: number;
declare const bj_TEXT_DELAY_MISSIONFAILED: number;
declare const bj_TEXT_DELAY_ALWAYSHINT: number;
declare const bj_TEXT_DELAY_HINT: number;
declare const bj_TEXT_DELAY_SECRET: number;
declare const bj_TEXT_DELAY_UNITACQUIRED: number;
declare const bj_TEXT_DELAY_UNITAVAILABLE: number;
declare const bj_TEXT_DELAY_ITEMACQUIRED: number;
declare const bj_TEXT_DELAY_WARNING: number;
declare const bj_QUEUE_DELAY_QUEST: number;
declare const bj_QUEUE_DELAY_HINT: number;
declare const bj_QUEUE_DELAY_SECRET: number;
declare const bj_HANDICAP_EASY: number;
declare const bj_GAME_STARTED_THRESHOLD: number;
declare const bj_WAIT_FOR_COND_MIN_INTERVAL: number;
declare const bj_POLLED_WAIT_INTERVAL: number;
declare const bj_POLLED_WAIT_SKIP_THRESHOLD: number;
declare const bj_MAX_INVENTORY: number;
declare const bj_MAX_PLAYERS: number;
declare const bj_PLAYER_NEUTRAL_VICTIM: number;
declare const bj_PLAYER_NEUTRAL_EXTRA: number;
declare const bj_MAX_PLAYER_SLOTS: number;
declare const bj_MAX_SKELETONS: number;
declare const bj_MAX_STOCK_ITEM_SLOTS: number;
declare const bj_MAX_STOCK_UNIT_SLOTS: number;
declare const bj_MAX_ITEM_LEVEL: number;
declare const bj_TOD_DAWN: number;
declare const bj_TOD_DUSK: number;
declare const bj_MELEE_STARTING_TOD: number;
declare const bj_MELEE_STARTING_GOLD_V0: number;
declare const bj_MELEE_STARTING_GOLD_V1: number;
declare const bj_MELEE_STARTING_LUMBER_V0: number;
declare const bj_MELEE_STARTING_LUMBER_V1: number;
declare const bj_MELEE_STARTING_HERO_TOKENS: number;
declare const bj_MELEE_HERO_LIMIT: number;
declare const bj_MELEE_HERO_TYPE_LIMIT: number;
declare const bj_MELEE_MINE_SEARCH_RADIUS: number;
declare const bj_MELEE_CLEAR_UNITS_RADIUS: number;
declare const bj_MELEE_CRIPPLE_TIMEOUT: number;
declare const bj_MELEE_CRIPPLE_MSG_DURATION: number;
declare const bj_MELEE_MAX_TWINKED_HEROES_V0: number;
declare const bj_MELEE_MAX_TWINKED_HEROES_V1: number;
declare const bj_CREEP_ITEM_DELAY: number;
declare const bj_STOCK_RESTOCK_INITIAL_DELAY: number;
declare const bj_STOCK_RESTOCK_INTERVAL: number;
declare const bj_STOCK_MAX_ITERATIONS: number;
declare const bj_MAX_DEST_IN_REGION_EVENTS: number;
declare const bj_CAMERA_MIN_FARZ: number;
declare const bj_CAMERA_DEFAULT_DISTANCE: number;
declare const bj_CAMERA_DEFAULT_FARZ: number;
declare const bj_CAMERA_DEFAULT_AOA: number;
declare const bj_CAMERA_DEFAULT_FOV: number;
declare const bj_CAMERA_DEFAULT_ROLL: number;
declare const bj_CAMERA_DEFAULT_ROTATION: number;
declare const bj_RESCUE_PING_TIME: number;
declare const bj_NOTHING_SOUND_DURATION: number;
declare const bj_TRANSMISSION_PING_TIME: number;
declare const bj_TRANSMISSION_IND_RED: number;
declare const bj_TRANSMISSION_IND_BLUE: number;
declare const bj_TRANSMISSION_IND_GREEN: number;
declare const bj_TRANSMISSION_IND_ALPHA: number;
declare const bj_TRANSMISSION_PORT_HANGTIME: number;
declare const bj_CINEMODE_INTERFACEFADE: number;
declare const bj_CINEMODE_GAMESPEED: gamespeed;
declare const bj_CINEMODE_VOLUME_UNITMOVEMENT: number;
declare const bj_CINEMODE_VOLUME_UNITSOUNDS: number;
declare const bj_CINEMODE_VOLUME_COMBAT: number;
declare const bj_CINEMODE_VOLUME_SPELLS: number;
declare const bj_CINEMODE_VOLUME_UI: number;
declare const bj_CINEMODE_VOLUME_MUSIC: number;
declare const bj_CINEMODE_VOLUME_AMBIENTSOUNDS: number;
declare const bj_CINEMODE_VOLUME_FIRE: number;
declare const bj_SPEECH_VOLUME_UNITMOVEMENT: number;
declare const bj_SPEECH_VOLUME_UNITSOUNDS: number;
declare const bj_SPEECH_VOLUME_COMBAT: number;
declare const bj_SPEECH_VOLUME_SPELLS: number;
declare const bj_SPEECH_VOLUME_UI: number;
declare const bj_SPEECH_VOLUME_MUSIC: number;
declare const bj_SPEECH_VOLUME_AMBIENTSOUNDS: number;
declare const bj_SPEECH_VOLUME_FIRE: number;
declare const bj_SMARTPAN_TRESHOLD_PAN: number;
declare const bj_SMARTPAN_TRESHOLD_SNAP: number;
declare const bj_MAX_QUEUED_TRIGGERS: number;
declare const bj_QUEUED_TRIGGER_TIMEOUT: number;
declare const bj_CAMPAIGN_INDEX_T: number;
declare const bj_CAMPAIGN_INDEX_H: number;
declare const bj_CAMPAIGN_INDEX_U: number;
declare const bj_CAMPAIGN_INDEX_O: number;
declare const bj_CAMPAIGN_INDEX_N: number;
declare const bj_CAMPAIGN_INDEX_XN: number;
declare const bj_CAMPAIGN_INDEX_XH: number;
declare const bj_CAMPAIGN_INDEX_XU: number;
declare const bj_CAMPAIGN_INDEX_XO: number;
declare const bj_CAMPAIGN_OFFSET_T: number;
declare const bj_CAMPAIGN_OFFSET_H: number;
declare const bj_CAMPAIGN_OFFSET_U: number;
declare const bj_CAMPAIGN_OFFSET_O: number;
declare const bj_CAMPAIGN_OFFSET_N: number;
declare const bj_CAMPAIGN_OFFSET_XN: number;
declare const bj_CAMPAIGN_OFFSET_XH: number;
declare const bj_CAMPAIGN_OFFSET_XU: number;
declare const bj_CAMPAIGN_OFFSET_XO: number;
declare const bj_MISSION_INDEX_T00: number;
declare const bj_MISSION_INDEX_T01: number;
declare const bj_MISSION_INDEX_H00: number;
declare const bj_MISSION_INDEX_H01: number;
declare const bj_MISSION_INDEX_H02: number;
declare const bj_MISSION_INDEX_H03: number;
declare const bj_MISSION_INDEX_H04: number;
declare const bj_MISSION_INDEX_H05: number;
declare const bj_MISSION_INDEX_H06: number;
declare const bj_MISSION_INDEX_H07: number;
declare const bj_MISSION_INDEX_H08: number;
declare const bj_MISSION_INDEX_H09: number;
declare const bj_MISSION_INDEX_H10: number;
declare const bj_MISSION_INDEX_H11: number;
declare const bj_MISSION_INDEX_U00: number;
declare const bj_MISSION_INDEX_U01: number;
declare const bj_MISSION_INDEX_U02: number;
declare const bj_MISSION_INDEX_U03: number;
declare const bj_MISSION_INDEX_U05: number;
declare const bj_MISSION_INDEX_U07: number;
declare const bj_MISSION_INDEX_U08: number;
declare const bj_MISSION_INDEX_U09: number;
declare const bj_MISSION_INDEX_U10: number;
declare const bj_MISSION_INDEX_U11: number;
declare const bj_MISSION_INDEX_O00: number;
declare const bj_MISSION_INDEX_O01: number;
declare const bj_MISSION_INDEX_O02: number;
declare const bj_MISSION_INDEX_O03: number;
declare const bj_MISSION_INDEX_O04: number;
declare const bj_MISSION_INDEX_O05: number;
declare const bj_MISSION_INDEX_O06: number;
declare const bj_MISSION_INDEX_O07: number;
declare const bj_MISSION_INDEX_O08: number;
declare const bj_MISSION_INDEX_O09: number;
declare const bj_MISSION_INDEX_O10: number;
declare const bj_MISSION_INDEX_N00: number;
declare const bj_MISSION_INDEX_N01: number;
declare const bj_MISSION_INDEX_N02: number;
declare const bj_MISSION_INDEX_N03: number;
declare const bj_MISSION_INDEX_N04: number;
declare const bj_MISSION_INDEX_N05: number;
declare const bj_MISSION_INDEX_N06: number;
declare const bj_MISSION_INDEX_N07: number;
declare const bj_MISSION_INDEX_N08: number;
declare const bj_MISSION_INDEX_N09: number;
declare const bj_MISSION_INDEX_XN00: number;
declare const bj_MISSION_INDEX_XN01: number;
declare const bj_MISSION_INDEX_XN02: number;
declare const bj_MISSION_INDEX_XN03: number;
declare const bj_MISSION_INDEX_XN04: number;
declare const bj_MISSION_INDEX_XN05: number;
declare const bj_MISSION_INDEX_XN06: number;
declare const bj_MISSION_INDEX_XN07: number;
declare const bj_MISSION_INDEX_XN08: number;
declare const bj_MISSION_INDEX_XN09: number;
declare const bj_MISSION_INDEX_XN10: number;
declare const bj_MISSION_INDEX_XH00: number;
declare const bj_MISSION_INDEX_XH01: number;
declare const bj_MISSION_INDEX_XH02: number;
declare const bj_MISSION_INDEX_XH03: number;
declare const bj_MISSION_INDEX_XH04: number;
declare const bj_MISSION_INDEX_XH05: number;
declare const bj_MISSION_INDEX_XH06: number;
declare const bj_MISSION_INDEX_XH07: number;
declare const bj_MISSION_INDEX_XH08: number;
declare const bj_MISSION_INDEX_XH09: number;
declare const bj_MISSION_INDEX_XU00: number;
declare const bj_MISSION_INDEX_XU01: number;
declare const bj_MISSION_INDEX_XU02: number;
declare const bj_MISSION_INDEX_XU03: number;
declare const bj_MISSION_INDEX_XU04: number;
declare const bj_MISSION_INDEX_XU05: number;
declare const bj_MISSION_INDEX_XU06: number;
declare const bj_MISSION_INDEX_XU07: number;
declare const bj_MISSION_INDEX_XU08: number;
declare const bj_MISSION_INDEX_XU09: number;
declare const bj_MISSION_INDEX_XU10: number;
declare const bj_MISSION_INDEX_XU11: number;
declare const bj_MISSION_INDEX_XU12: number;
declare const bj_MISSION_INDEX_XU13: number;
declare const bj_MISSION_INDEX_XO00: number;
declare const bj_CINEMATICINDEX_TOP: number;
declare const bj_CINEMATICINDEX_HOP: number;
declare const bj_CINEMATICINDEX_HED: number;
declare const bj_CINEMATICINDEX_OOP: number;
declare const bj_CINEMATICINDEX_OED: number;
declare const bj_CINEMATICINDEX_UOP: number;
declare const bj_CINEMATICINDEX_UED: number;
declare const bj_CINEMATICINDEX_NOP: number;
declare const bj_CINEMATICINDEX_NED: number;
declare const bj_CINEMATICINDEX_XOP: number;
declare const bj_CINEMATICINDEX_XED: number;
declare const bj_ALLIANCE_UNALLIED: number;
declare const bj_ALLIANCE_UNALLIED_VISION: number;
declare const bj_ALLIANCE_ALLIED: number;
declare const bj_ALLIANCE_ALLIED_VISION: number;
declare const bj_ALLIANCE_ALLIED_UNITS: number;
declare const bj_ALLIANCE_ALLIED_ADVUNITS: number;
declare const bj_ALLIANCE_NEUTRAL: number;
declare const bj_ALLIANCE_NEUTRAL_VISION: number;
declare const bj_KEYEVENTTYPE_DEPRESS: number;
declare const bj_KEYEVENTTYPE_RELEASE: number;
declare const bj_KEYEVENTKEY_LEFT: number;
declare const bj_KEYEVENTKEY_RIGHT: number;
declare const bj_KEYEVENTKEY_DOWN: number;
declare const bj_KEYEVENTKEY_UP: number;
declare const bj_TIMETYPE_ADD: number;
declare const bj_TIMETYPE_SET: number;
declare const bj_TIMETYPE_SUB: number;
declare const bj_CAMERABOUNDS_ADJUST_ADD: number;
declare const bj_CAMERABOUNDS_ADJUST_SUB: number;
declare const bj_QUESTTYPE_REQ_DISCOVERED: number;
declare const bj_QUESTTYPE_REQ_UNDISCOVERED: number;
declare const bj_QUESTTYPE_OPT_DISCOVERED: number;
declare const bj_QUESTTYPE_OPT_UNDISCOVERED: number;
declare const bj_QUESTMESSAGE_DISCOVERED: number;
declare const bj_QUESTMESSAGE_UPDATED: number;
declare const bj_QUESTMESSAGE_COMPLETED: number;
declare const bj_QUESTMESSAGE_FAILED: number;
declare const bj_QUESTMESSAGE_REQUIREMENT: number;
declare const bj_QUESTMESSAGE_MISSIONFAILED: number;
declare const bj_QUESTMESSAGE_ALWAYSHINT: number;
declare const bj_QUESTMESSAGE_HINT: number;
declare const bj_QUESTMESSAGE_SECRET: number;
declare const bj_QUESTMESSAGE_UNITACQUIRED: number;
declare const bj_QUESTMESSAGE_UNITAVAILABLE: number;
declare const bj_QUESTMESSAGE_ITEMACQUIRED: number;
declare const bj_QUESTMESSAGE_WARNING: number;
declare const bj_SORTTYPE_SORTBYVALUE: number;
declare const bj_SORTTYPE_SORTBYPLAYER: number;
declare const bj_SORTTYPE_SORTBYLABEL: number;
declare const bj_CINEFADETYPE_FADEIN: number;
declare const bj_CINEFADETYPE_FADEOUT: number;
declare const bj_CINEFADETYPE_FADEOUTIN: number;
declare const bj_REMOVEBUFFS_POSITIVE: number;
declare const bj_REMOVEBUFFS_NEGATIVE: number;
declare const bj_REMOVEBUFFS_ALL: number;
declare const bj_REMOVEBUFFS_NONTLIFE: number;
declare const bj_BUFF_POLARITY_POSITIVE: number;
declare const bj_BUFF_POLARITY_NEGATIVE: number;
declare const bj_BUFF_POLARITY_EITHER: number;
declare const bj_BUFF_RESIST_MAGIC: number;
declare const bj_BUFF_RESIST_PHYSICAL: number;
declare const bj_BUFF_RESIST_EITHER: number;
declare const bj_BUFF_RESIST_BOTH: number;
declare const bj_HEROSTAT_STR: number;
declare const bj_HEROSTAT_AGI: number;
declare const bj_HEROSTAT_INT: number;
declare const bj_MODIFYMETHOD_ADD: number;
declare const bj_MODIFYMETHOD_SUB: number;
declare const bj_MODIFYMETHOD_SET: number;
declare const bj_UNIT_STATE_METHOD_ABSOLUTE: number;
declare const bj_UNIT_STATE_METHOD_RELATIVE: number;
declare const bj_UNIT_STATE_METHOD_DEFAULTS: number;
declare const bj_UNIT_STATE_METHOD_MAXIMUM: number;
declare const bj_GATEOPERATION_CLOSE: number;
declare const bj_GATEOPERATION_OPEN: number;
declare const bj_GATEOPERATION_DESTROY: number;
declare const bj_GAMECACHE_BOOLEAN: number;
declare const bj_GAMECACHE_INTEGER: number;
declare const bj_GAMECACHE_REAL: number;
declare const bj_GAMECACHE_UNIT: number;
declare const bj_GAMECACHE_STRING: number;
declare const bj_HASHTABLE_BOOLEAN: number;
declare const bj_HASHTABLE_INTEGER: number;
declare const bj_HASHTABLE_REAL: number;
declare const bj_HASHTABLE_STRING: number;
declare const bj_HASHTABLE_HANDLE: number;
declare const bj_ITEM_STATUS_HIDDEN: number;
declare const bj_ITEM_STATUS_OWNED: number;
declare const bj_ITEM_STATUS_INVULNERABLE: number;
declare const bj_ITEM_STATUS_POWERUP: number;
declare const bj_ITEM_STATUS_SELLABLE: number;
declare const bj_ITEM_STATUS_PAWNABLE: number;
declare const bj_ITEMCODE_STATUS_POWERUP: number;
declare const bj_ITEMCODE_STATUS_SELLABLE: number;
declare const bj_ITEMCODE_STATUS_PAWNABLE: number;
declare const bj_MINIMAPPINGSTYLE_SIMPLE: number;
declare const bj_MINIMAPPINGSTYLE_FLASHY: number;
declare const bj_MINIMAPPINGSTYLE_ATTACK: number;
declare const bj_CORPSE_MAX_DEATH_TIME: number;
declare const bj_CORPSETYPE_FLESH: number;
declare const bj_CORPSETYPE_BONE: number;
declare const bj_ELEVATOR_BLOCKER_CODE: number;
declare const bj_ELEVATOR_CODE01: number;
declare const bj_ELEVATOR_CODE02: number;
declare const bj_ELEVATOR_WALL_TYPE_ALL: number;
declare const bj_ELEVATOR_WALL_TYPE_EAST: number;
declare const bj_ELEVATOR_WALL_TYPE_NORTH: number;
declare const bj_ELEVATOR_WALL_TYPE_SOUTH: number;
declare const bj_ELEVATOR_WALL_TYPE_WEST: number;
declare var bj_FORCE_ALL_PLAYERS: force;
declare var bj_FORCE_PLAYER: force[];
declare var bj_MELEE_MAX_TWINKED_HEROES: number;
declare var bj_mapInitialPlayableArea: rect;
declare var bj_mapInitialCameraBounds: rect;
declare var bj_forLoopAIndex: number;
declare var bj_forLoopBIndex: number;
declare var bj_forLoopAIndexEnd: number;
declare var bj_forLoopBIndexEnd: number;
declare var bj_slotControlReady: boolean;
declare var bj_slotControlUsed: boolean[];
declare var bj_slotControl: mapcontrol[];
declare var bj_gameStartedTimer: timer;
declare var bj_gameStarted: boolean;
declare var bj_volumeGroupsTimer: timer;
declare var bj_isSinglePlayer: boolean;
declare var bj_dncSoundsDay: trigger;
declare var bj_dncSoundsNight: trigger;
declare var bj_dayAmbientSound: sound;
declare var bj_nightAmbientSound: sound;
declare var bj_dncSoundsDawn: trigger;
declare var bj_dncSoundsDusk: trigger;
declare var bj_dawnSound: sound;
declare var bj_duskSound: sound;
declare var bj_useDawnDuskSounds: boolean;
declare var bj_dncIsDaytime: boolean;
declare var bj_rescueSound: sound;
declare var bj_questDiscoveredSound: sound;
declare var bj_questUpdatedSound: sound;
declare var bj_questCompletedSound: sound;
declare var bj_questFailedSound: sound;
declare var bj_questHintSound: sound;
declare var bj_questSecretSound: sound;
declare var bj_questItemAcquiredSound: sound;
declare var bj_questWarningSound: sound;
declare var bj_victoryDialogSound: sound;
declare var bj_defeatDialogSound: sound;
declare var bj_stockItemPurchased: trigger;
declare var bj_stockUpdateTimer: timer;
declare var bj_stockAllowedPermanent: boolean[];
declare var bj_stockAllowedCharged: boolean[];
declare var bj_stockAllowedArtifact: boolean[];
declare var bj_stockPickedItemLevel: number;
declare var bj_stockPickedItemType: itemtype;
declare var bj_meleeVisibilityTrained: trigger;
declare var bj_meleeVisibilityIsDay: boolean;
declare var bj_meleeGrantHeroItems: boolean;
declare var bj_meleeNearestMineToLoc: location;
declare var bj_meleeNearestMine: unit;
declare var bj_meleeNearestMineDist: number;
declare var bj_meleeGameOver: boolean;
declare var bj_meleeDefeated: boolean[];
declare var bj_meleeVictoried: boolean[];
declare var bj_ghoul: unit[];
declare var bj_crippledTimer: timer[];
declare var bj_crippledTimerWindows: timerdialog[];
declare var bj_playerIsCrippled: boolean[];
declare var bj_playerIsExposed: boolean[];
declare var bj_finishSoonAllExposed: boolean;
declare var bj_finishSoonTimerDialog: timerdialog;
declare var bj_meleeTwinkedHeroes: number[];
declare var bj_rescueUnitBehavior: trigger;
declare var bj_rescueChangeColorUnit: boolean;
declare var bj_rescueChangeColorBldg: boolean;
declare var bj_cineSceneEndingTimer: timer;
declare var bj_cineSceneLastSound: sound;
declare var bj_cineSceneBeingSkipped: trigger;
declare var bj_cineModePriorSpeed: gamespeed;
declare var bj_cineModePriorFogSetting: boolean;
declare var bj_cineModePriorMaskSetting: boolean;
declare var bj_cineModeAlreadyIn: boolean;
declare var bj_cineModePriorDawnDusk: boolean;
declare var bj_cineModeSavedSeed: number;
declare var bj_cineFadeFinishTimer: timer;
declare var bj_cineFadeContinueTimer: timer;
declare var bj_cineFadeContinueRed: number;
declare var bj_cineFadeContinueGreen: number;
declare var bj_cineFadeContinueBlue: number;
declare var bj_cineFadeContinueTrans: number;
declare var bj_cineFadeContinueDuration: number;
declare var bj_cineFadeContinueTex: string;
declare var bj_queuedExecTotal: number;
declare var bj_queuedExecTriggers: trigger[];
declare var bj_queuedExecUseConds: boolean[];
declare var bj_queuedExecTimeoutTimer: timer;
declare var bj_queuedExecTimeout: trigger;
declare var bj_destInRegionDiesCount: number;
declare var bj_destInRegionDiesTrig: trigger;
declare var bj_groupCountUnits: number;
declare var bj_forceCountPlayers: number;
declare var bj_groupEnumTypeId: number;
declare var bj_groupEnumOwningPlayer: player;
declare var bj_groupAddGroupDest: group;
declare var bj_groupRemoveGroupDest: group;
declare var bj_groupRandomConsidered: number;
declare var bj_groupRandomCurrentPick: unit;
declare var bj_groupLastCreatedDest: group;
declare var bj_randomSubGroupGroup: group;
declare var bj_randomSubGroupWant: number;
declare var bj_randomSubGroupTotal: number;
declare var bj_randomSubGroupChance: number;
declare var bj_destRandomConsidered: number;
declare var bj_destRandomCurrentPick: destructable;
declare var bj_elevatorWallBlocker: destructable;
declare var bj_elevatorNeighbor: destructable;
declare var bj_itemRandomConsidered: number;
declare var bj_itemRandomCurrentPick: item;
declare var bj_forceRandomConsidered: number;
declare var bj_forceRandomCurrentPick: player;
declare var bj_makeUnitRescuableUnit: unit;
declare var bj_makeUnitRescuableFlag: boolean;
declare var bj_pauseAllUnitsFlag: boolean;
declare var bj_enumDestructableCenter: location;
declare var bj_enumDestructableRadius: number;
declare var bj_setPlayerTargetColor: playercolor;
declare var bj_isUnitGroupDeadResult: boolean;
declare var bj_isUnitGroupEmptyResult: boolean;
declare var bj_isUnitGroupInRectResult: boolean;
declare var bj_isUnitGroupInRectRect: rect;
declare var bj_changeLevelShowScores: boolean;
declare var bj_changeLevelMapName: string;
declare var bj_suspendDecayFleshGroup: group;
declare var bj_suspendDecayBoneGroup: group;
declare var bj_delayedSuspendDecayTimer: timer;
declare var bj_delayedSuspendDecayTrig: trigger;
declare var bj_livingPlayerUnitsTypeId: number;
declare var bj_lastDyingWidget: widget;
declare var bj_randDistCount: number;
declare var bj_randDistID: number[];
declare var bj_randDistChance: number[];
declare var bj_lastCreatedUnit: unit;
declare var bj_lastCreatedItem: item;
declare var bj_lastRemovedItem: item;
declare var bj_lastHauntedGoldMine: unit;
declare var bj_lastCreatedDestructable: destructable;
declare var bj_lastCreatedGroup: group;
declare var bj_lastCreatedFogModifier: fogmodifier;
declare var bj_lastCreatedEffect: effect;
declare var bj_lastCreatedWeatherEffect: weathereffect;
declare var bj_lastCreatedTerrainDeformation: terraindeformation;
declare var bj_lastCreatedQuest: quest;
declare var bj_lastCreatedQuestItem: questitem;
declare var bj_lastCreatedDefeatCondition: defeatcondition;
declare var bj_lastStartedTimer: timer;
declare var bj_lastCreatedTimerDialog: timerdialog;
declare var bj_lastCreatedLeaderboard: leaderboard;
declare var bj_lastCreatedMultiboard: multiboard;
declare var bj_lastPlayedSound: sound;
declare var bj_lastPlayedMusic: string;
declare var bj_lastTransmissionDuration: number;
declare var bj_lastCreatedGameCache: gamecache;
declare var bj_lastCreatedHashtable: hashtable;
declare var bj_lastLoadedUnit: unit;
declare var bj_lastCreatedButton: button;
declare var bj_lastReplacedUnit: unit;
declare var bj_lastCreatedTextTag: texttag;
declare var bj_lastCreatedLightning: lightning;
declare var bj_lastCreatedImage: image;
declare var bj_lastCreatedUbersplat: ubersplat;
declare var filterIssueHauntOrderAtLocBJ: boolexpr | (() => boolean) | null;
declare var filterEnumDestructablesInCircleBJ: boolexpr | (() => boolean) | null;
declare var filterGetUnitsInRectOfPlayer: boolexpr | (() => boolean) | null;
declare var filterGetUnitsOfTypeIdAll: boolexpr | (() => boolean) | null;
declare var filterGetUnitsOfPlayerAndTypeId: boolexpr | (() => boolean) | null;
declare var filterMeleeTrainedUnitIsHeroBJ: boolexpr | (() => boolean) | null;
declare var filterLivingPlayerUnitsOfTypeId: boolexpr | (() => boolean) | null;
declare var bj_wantDestroyGroup: boolean;


/**
 * 显示Debug消息 [C]  
 * 显示Debug信息: ${文字}
 *
 * @remark
 * 对玩家发送持续60秒的信息. 一般用于地图调试.
 *
 * @TC_GAME
 */
declare function BJDebugMsg(msg: string): void;

/**
 * 取较小值  
 * 取(${实数1}, ${实数2})中较小值
 *
 * @TC_MATH
 */
declare function RMinBJ(a: number, b: number): number;

/**
 * 取较大值  
 * 取(${实数1}, ${实数2})中较大值
 *
 * @TC_MATH
 */
declare function RMaxBJ(a: number, b: number): number;

/**
 * 绝对值  
 * ${实数} 的绝对值
 *
 * @TC_MATH
 */
declare function RAbsBJ(a: number): number;

/**
 * 符号标志  
 * ${实数} 的符号标志
 *
 * @remark
 * 负数为-1. 非负数为1.
 *
 * @TC_MATH
 */
declare function RSignBJ(a: number): number;

/**
 * 取较小值  
 * 取(${整数1}, ${整数2})中较小值
 *
 * @TC_MATH
 */
declare function IMinBJ(a: number, b: number): number;

/**
 * 取较大值  
 * 取(${整数1}, ${整数2})中较大值
 *
 * @TC_MATH
 */
declare function IMaxBJ(a: number, b: number): number;

/**
 * 绝对值  
 * ${整数} 的绝对值
 *
 * @TC_MATH
 */
declare function IAbsBJ(a: number): number;

/**
 * 符号标志  
 * ${整数} 的符号标志
 *
 * @remark
 * 负数为-1. 非负数为1.
 *
 * @TC_MATH
 */
declare function ISignBJ(a: number): number;

/**
 * 正弦(角度)  
 * @Sin(${Angle})
 *
 * @remark
 * 采用角度制计算.
 *
 * @TC_MATH
 */
declare function SinBJ(degrees: number): number;

/**
 * 余弦(角度)  
 * @Cos(${Angle})
 *
 * @remark
 * 采用角度制计算.
 *
 * @TC_MATH
 */
declare function CosBJ(degrees: number): number;

/**
 * 正切(角度)  
 * @Tan(${Angle})
 *
 * @remark
 * 采用角度制计算.
 *
 * @TC_MATH
 */
declare function TanBJ(degrees: number): number;

/**
 * 反正弦(角度)  
 * @Asin(${数值})
 *
 * @remark
 * 采用角度制计算. 返回角度取值-90 — 90.
 *
 * @TC_MATH
 */
declare function AsinBJ(degrees: number): number;

/**
 * 反余弦(角度)  
 * @Acos(${数值})
 *
 * @remark
 * 采用角度制计算. 返回角度取值0 — 180.
 *
 * @TC_MATH
 */
declare function AcosBJ(degrees: number): number;

/**
 * 反正切(角度)  
 * @Atan(${数值})
 *
 * @remark
 * 采用角度制计算. 返回角度取值-90 — 90.
 *
 * @TC_MATH
 */
declare function AtanBJ(degrees: number): number;

/**
 * 反正切(角度)(Y:X)  
 * @Atan(${Y} : ${X})
 *
 * @remark
 * 采用角度制计算. 返回角度取值-90 — 90.
 *
 * @TC_MATH
 */
declare function Atan2BJ(y: number, x: number): number;

/**
 * 两点间方向  
 * ${点} 到 ${点} 的角度
 *
 * @remark
 * 取值-180 - 180.
 *
 * @TC_MATH
 */
declare function AngleBetweenPoints(locA: location, locB: location): number;

/**
 * 两点间距  
 * ${点} 和 ${点} 之间的距离
 *
 * @TC_MATH
 */
declare function DistanceBetweenPoints(locA: location, locB: location): number;

/**
 * 极坐标位移点  
 * 从 ${指定点} 开始,距离 ${Distance} ,方向为 ${Angle} 度的位移处
 *
 * @remark
 * 会创建点.
 *
 * @TC_NOTHING
 */
declare function PolarProjectionBJ(source: location, dist: number, angle: number): location;

/**
 * 随机角度  
 * 随机角度
 *
 * @remark
 * 0-360的随机角度.
 *
 * @TC_MATH
 */
declare function GetRandomDirectionDeg(): number;

/**
 * 随机百分数  
 * 随机百分数
 *
 * @remark
 * 0-100的随机实数.
 *
 * @TC_MATH
 */
declare function GetRandomPercentageBJ(): number;

/**
 * 矩形区域内随机点  
 * ${矩形区域} 内的随机点
 *
 * @remark
 * 会创建点.
 *
 * @TC_NOTHING
 */
declare function GetRandomLocInRect(whichRect: rect): location;

/**
 * 模  
 * ${被除数} mod ${除数}
 *
 * @remark
 * 取模计算,例: 13 mod 5
 *
 * @TC_MATH
 */
declare function ModuloInteger(dividend: number, divisor: number): number;

/**
 * 模  
 * ${被除数} mod ${除数}
 *
 * @remark
 * 取模计算,例: 9.0 mod 2.5
 *
 * @TC_MATH
 */
declare function ModuloReal(dividend: number, divisor: number): number;

/**
 * 坐标位移点  
 * ${指定点} 坐标位移 (${X}, ${Y})处
 *
 * @remark
 * 会创建点.
 *
 * @TC_NOTHING
 */
declare function OffsetLocation(loc: location, dx: number, dy: number): location;

/**
 * 位移创建矩形区域  
 * 与 ${矩形区域} 位移 (${X}, ${Y}) 坐标之后等价的矩形区域
 *
 * @remark
 * 会创建矩形区域.
 *
 * @TC_NOTHING
 */
declare function OffsetRectBJ(r: rect, dx: number, dy: number): rect;

/**
 * 新建矩形区域(指定中心点)  
 * 以 ${指定点} 为中心,宽 ${数值} ,高 ${数值} 的矩形区域
 *
 * @remark
 * 会创建矩形区域.
 *
 * @TC_NOTHING
 */
declare function RectFromCenterSizeBJ(center: location, width: number, height: number): rect;
declare function RectContainsCoords(r: rect, x: number, y: number): boolean;

/**
 * 包含点  
 * ${矩形区域} 内包含 ${点}
 *
 * @TC_RECT
 */
declare function RectContainsLoc(r: rect, loc: location): boolean;

/**
 * 在矩形区域内  
 * ${矩形区域} 内存在 ${单位}
 *
 * @TC_UNIT
 */
declare function RectContainsUnit(r: rect, whichUnit: unit): boolean;

/**
 * 物品在矩形区域  
 * ${物品} 在 ${矩形区域}
 *
 * @remark
 * 单位持有的物品不会被计算在内.
 *
 * @TC_ITEM
 */
declare function RectContainsItem(whichItem: item, r: rect): boolean;

/**
 * 运行触发(检查条件)  
 * 运行 ${触发} (检查条件)
 *
 * @remark
 * 如果其触发条件成立则运行触发动作.
 *
 * @TC_TRIGGER
 */
declare function ConditionalTriggerExecute(trig: trigger): void;
declare function TriggerExecuteBJ(trig: trigger, checkConditions: boolean): boolean;
declare function PostTriggerExecuteBJ(trig: trigger, checkConditions: boolean): boolean;
declare function QueuedTriggerCheck(): void;
declare function QueuedTriggerGetIndex(trig: trigger): number;
declare function QueuedTriggerRemoveByIndex(trigIndex: number): boolean;
declare function QueuedTriggerAttemptExec(): boolean;

/**
 * 添加到触发队列  
 * 添加 ${触发} 到触发队列(${Checking/Ignoring} 条件)
 *
 * @remark
 * 个人认为触发队列属于没用的功能.
 *
 * @TC_TRIGGER
 */
declare function QueuedTriggerAddBJ(trig: trigger, checkConditions: boolean): boolean;

/**
 * 移出触发队列  
 * 将 ${触发} 移出触发队列
 *
 * @remark
 * 如果触发正在运行,从队列移出该单位将允许后面的触发运行,但不影响本身的动作.
 *
 * @TC_TRIGGER
 */
declare function QueuedTriggerRemoveBJ(trig: trigger): void;
declare function QueuedTriggerDoneBJ(): void;

/**
 * 清空触发队列  
 * 清空触发队列中所有触发
 *
 * @TC_TRIGGER
 */
declare function QueuedTriggerClearBJ(): void;

/**
 * 清空未运行触发  
 * 清空触发队列中所有未运行触发
 *
 * @remark
 * 只有正在运行的触发不会被移出队列.
 *
 * @TC_TRIGGER
 */
declare function QueuedTriggerClearInactiveBJ(): void;

/**
 * 队列中触发数量  
 * 触发队列中的触发数量
 *
 * @remark
 * 可使用'触发器 - 添加到队列'和'触发器 - 移出队列'动作来操作触发队列.
 *
 * @TC_TRIGGER
 */
declare function QueuedTriggerCountBJ(): number;

/**
 * 触发队列为空  
 * 触发队列为空
 *
 * @remark
 * 可使用'触发器 - 添加到队列'和'触发器 - 移出队列'动作来操作触发队列.
 *
 * @TC_TRIGGER
 */
declare function IsTriggerQueueEmptyBJ(): boolean;

/**
 * 触发在队列中  
 * ${触发} 在队列中
 *
 * @remark
 * 可使用'触发器 - 添加到队列'和'触发器 - 移出队列'动作来操作触发队列.
 *
 * @TC_TRIGGER
 */
declare function IsTriggerQueuedBJ(trig: trigger): boolean;

/**
 * 循环整数A  
 * 循环整数A
 *
 * @TC_FORLOOP
 */
declare function GetForLoopIndexA(): number;

/**
 * 设置循环整数A [R]  
 * 设置循环整数A的值为 ${数值}
 *
 * @TC_FORLOOP
 */
declare function SetForLoopIndexA(newIndex: number): void;

/**
 * 循环整数B  
 * 循环整数B
 *
 * @TC_FORLOOP
 */
declare function GetForLoopIndexB(): number;

/**
 * 设置循环整数B [R]  
 * 设置循环整数B的值为 ${数值}
 *
 * @TC_FORLOOP
 */
declare function SetForLoopIndexB(newIndex: number): void;

/**
 * 等待(游戏时间)  
 * 等待 ${Time} 秒(游戏时间)
 *
 * @remark
 * 该延迟功能受游戏时间的影响.通过调整游戏速度来调节该功能的具体延迟时间的长短.
 *
 * @TC_WAIT
 */
declare function PolledWait(duration: number): void;
declare function IntegerTertiaryOp(flag: boolean, valueA: number, valueB: number): number;

/**
 * 不做任何动作  
 * 不做任何动作
 *
 * @TC_NOTHING
 */
declare function DoNothing(): void;

/**
 * 文本注释  
 * -------- ${注释文本} --------
 *
 * @TC_COMMENT
 */
declare function CommentString(commentString: string): void;

/**
 * 本地字符串  
 * 本地字符串: ${文字}
 *
 * @remark
 * 获取ui\\framedef\\globalstrings.fdf中定义的字符串.
 *
 * @TC_CONVERSION
 */
declare function StringIdentity(theString: string): string;

/**
 * And  
 * ${条件 1} 且 ${条件 2}
 *
 * @remark
 * 条件1 和条件2 均成立.
 *
 * @TC_CONDITION
 */
declare function GetBooleanAnd(valueA: boolean, valueB: boolean): boolean;

/**
 * Or  
 * ${条件 1} or ${条件 2}
 *
 * @remark
 * 条件1 和条件2 任意成立.
 *
 * @TC_CONDITION
 */
declare function GetBooleanOr(valueA: boolean, valueB: boolean): boolean;
declare function PercentToInt(percentage: number, max: number): number;
declare function PercentTo255(percentage: number): number;

/**
 * 游戏时间  
 * 游戏时间
 *
 * @remark
 * 游戏中的昼夜时间.
 *
 * @TC_GAME
 */
declare function GetTimeOfDay(): number;

/**
 * 设置游戏时间  
 * 设置游戏时间为 ${Time}
 *
 * @remark
 * 游戏时间采用24小时制.
 *
 * @TC_GAME
 */
declare function SetTimeOfDay(whatTime: number): void;

/**
 * 设置昼夜时间流逝速度  
 * 设置昼夜时间流逝速度为默认值的 ${Percent}%
 *
 * @remark
 * 设置100%来恢复正常值. 该值并不影响游戏速度.
 *
 * @TC_GAME
 */
declare function SetTimeOfDayScalePercentBJ(scalePercent: number): void;

/**
 * 昼夜时间流逝速度  
 * 昼夜时间流逝速度
 *
 * @remark
 * 百分比数值, 100为默认值.
 *
 * @TC_GAME
 */
declare function GetTimeOfDayScalePercentBJ(): number;
declare function PlaySound(soundName: string): void;
declare function CompareLocationsBJ(A: location, B: location): boolean;
declare function CompareRectsBJ(A: rect, B: rect): boolean;
declare function GetRectFromCircleBJ(center: location, radius: number): rect;

/**
 * 玩家当前镜头  
 * 玩家当前镜头
 *
 * @remark
 * 注意:该函数对各玩家返回值不同,请确定你知道自己在做什么,否则很容易引起掉线. 会创建镜头对象,但每个玩家只会有一个当前镜头.
 *
 * @TC_NOTHING
 */
declare function GetCurrentCameraSetup(): camerasetup;

/**
 * 应用镜头(指定玩家)(限时)  
 * ${应用方式} ${镜头} 作用于 ${Player},持续 ${Time} 秒
 *
 * @TC_CAMERA
 */
declare function CameraSetupApplyForPlayer(doPan: boolean, whichSetup: camerasetup, whichPlayer: player, duration: number): void;

/**
 * 镜头属性(指定镜头)  
 * ${Camera Field} 对 ${镜头}
 *
 * @TC_CAMERA
 */
declare function CameraSetupGetFieldSwap(whichField: camerafield, whichSetup: camerasetup): number;

/**
 * 设置镜头属性(指定玩家)(限时)  
 * 设置 ${Player} 的镜头属性 ${Field} 为 ${Value},持续 ${Time} 秒
 *
 * @TC_CAMERA
 */
declare function SetCameraFieldForPlayer(whichPlayer: player, whichField: camerafield, value: number, duration: number): void;

/**
 * 锁定镜头到单位(指定玩家)  
 * 锁定 ${Player} 的镜头到 ${单位}, 偏移坐标(${X}, ${Y}) ,使用 ${Rotation Source}
 *
 * @remark
 * 偏移坐标(X,Y)以单位脚底为原点坐标.
 *
 * @TC_CAMERA
 */
declare function SetCameraTargetControllerNoZForPlayer(whichPlayer: player, whichUnit: unit, xoffset: number, yoffset: number, inheritOrientation: boolean): void;
declare function SetCameraPositionForPlayer(whichPlayer: player, x: number, y: number): void;
declare function SetCameraPositionLocForPlayer(whichPlayer: player, loc: location): void;

/**
 * 指定点旋转镜头(指定玩家)(角度)(限时)  
 * 旋转角度为${Angle} 度,以 ${点} 为中心,应用于 ${Player},持续 ${Time} 秒
 *
 * @TC_CAMERA
 */
declare function RotateCameraAroundLocBJ(degrees: number, loc: location, whichPlayer: player, duration: number): void;
declare function PanCameraToForPlayer(whichPlayer: player, x: number, y: number): void;
declare function PanCameraToLocForPlayer(whichPlayer: player, loc: location): void;
declare function PanCameraToTimedForPlayer(whichPlayer: player, x: number, y: number, duration: number): void;

/**
 * 平移镜头(指定玩家)(限时)  
 * 平移 ${Player} 的镜头到 ${点},持续 ${Time} 秒
 *
 * @TC_CAMERA
 */
declare function PanCameraToTimedLocForPlayer(whichPlayer: player, loc: location, duration: number): void;

/**
 * 指定高度平移镜头(指定玩家)(限时)  
 * 平移 ${Player} 的镜头到 ${Point} 距离地面高度为 ${Z},持续 ${Time} 秒
 *
 * @remark
 * 在指定移动路径上镜头不会低于地面高度.
 *
 * @TC_CAMERA
 */
declare function PanCameraToTimedLocWithZForPlayer(whichPlayer: player, loc: location, zOffset: number, duration: number): void;

/**
 * 在必要时平移镜头(指定玩家)(限时)  
 * 在必要时平移 ${Player} 的镜头到 ${指定点} ,持续 ${Time} 秒
 *
 * @remark
 * 如果距离过远则直接跳转镜头,如果过近则不做动作.
 *
 * @TC_CAMERA
 */
declare function SmartCameraPanBJ(whichPlayer: player, loc: location, duration: number): void;

/**
 * 播放电影镜头(指定玩家)  
 * 对 ${Player} 播放电影镜头: ${Camera File}
 *
 * @remark
 * 在'Objects\\CinematicCameras'目录下有一些电影镜头,可用Mpq工具来查询.
 *
 * @TC_CAMERA
 */
declare function SetCinematicCameraForPlayer(whichPlayer: player, cameraModelFile: string): void;

/**
 * 重置游戏镜头(指定玩家)  
 * 重置 ${Player} 的镜头为游戏默认状态,持续 ${Time} 秒
 *
 * @TC_CAMERA
 */
declare function ResetToGameCameraForPlayer(whichPlayer: player, duration: number): void;

/**
 * 摇晃镜头源(指定玩家)  
 * 摇晃 ${Player} 的镜头源, 摇晃幅度: ${Magnitude} 速率: ${Velocity}
 *
 * @remark
 * 使用'镜头 - 重置镜头'或'镜头 - 停止摇晃镜头'来停止摇晃.
 *
 * @TC_CAMERA
 */
declare function CameraSetSourceNoiseForPlayer(whichPlayer: player, magnitude: number, velocity: number): void;

/**
 * 摇晃镜头目标(指定玩家)  
 * 摇晃 ${Player} 的镜头目标, 摇晃幅度: ${Magnitude} 速率: ${Velocity}
 *
 * @remark
 * 使用'镜头 - 重置镜头'或'镜头 - 停止摇晃镜头'来停止摇晃.
 *
 * @TC_CAMERA
 */
declare function CameraSetTargetNoiseForPlayer(whichPlayer: player, magnitude: number, velocity: number): void;

/**
 * 震动镜头(指定玩家)  
 * 震动 ${Player} 的镜头, 震动幅度: ${Magnitude}
 *
 * @remark
 * 使用'镜头 - 重置镜头'或'镜头 - 停止震动镜头'来停止震动.
 *
 * @TC_CAMERA
 */
declare function CameraSetEQNoiseForPlayer(whichPlayer: player, magnitude: number): void;

/**
 * 停止摇晃/震动镜头(指定玩家)  
 * 停止 ${Player} 镜头的摇晃和震动
 *
 * @remark
 * 可以用本地玩家实现对所有玩家停止摇晃/震动镜头.
 *
 * @TC_CAMERA
 */
declare function CameraClearNoiseForPlayer(whichPlayer: player): void;

/**
 * 当前可用镜头范围  
 * 当前可用镜头范围
 *
 * @remark
 * 会创建矩形区域. 注意:该函数对各玩家返回值不同,请确定你知道自己在做什么,否则很容易引起掉线.
 *
 * @TC_NOTHING
 */
declare function GetCurrentCameraBoundsMapRectBJ(): rect;

/**
 * 初始可用镜头范围  
 * 初始可用镜头范围
 *
 * @remark
 * 在地图编辑器的地图属性中设置.
 *
 * @TC_NOTHING
 */
declare function GetCameraBoundsMapRect(): rect;

/**
 * 可用地图区域  
 * 可用地图区域
 *
 * @remark
 * 在地图编辑器的地图属性中设置.
 *
 * @TC_NOTHING
 */
declare function GetPlayableMapRect(): rect;

/**
 * 完整地图区域  
 * 完整地图区域
 *
 * @remark
 * 在地图编辑器的地图属性中设置. 会创建矩形区域.
 *
 * @TC_NOTHING
 */
declare function GetEntireMapRect(): rect;
declare function SetCameraBoundsToRect(r: rect): void;

/**
 * 设置可用镜头区域(指定玩家)  
 * 设置 ${Player} 的可用镜头区域为 ${地区}
 *
 * @remark
 * 该动作同样会影响小地图的显示. 但小地图的图片是无法改变的. 实际可用区域要大于可用镜头区域.
 *
 * @TC_CAMERA
 */
declare function SetCameraBoundsToRectForPlayerBJ(whichPlayer: player, r: rect): void;
declare function AdjustCameraBoundsBJ(adjustMethod: number, dxWest: number, dxEast: number, dyNorth: number, dySouth: number): void;

/**
 * 扩张/收缩 可用镜头区域(指定玩家)  
 * ${Extend/Shrink} ${Player} 的可用镜头区域, 西: ${West} ,东 ${East} ,北: ${North} ,南: ${South}
 *
 * @remark
 * 该动作同样会影响小地图的显示. 但小地图的图片是无法改变的. 实际可用区域要大于可用镜头区域.
 *
 * @TC_CAMERA
 */
declare function AdjustCameraBoundsForPlayerBJ(adjustMethod: number, whichPlayer: player, dxWest: number, dxEast: number, dyNorth: number, dySouth: number): void;
declare function SetCameraQuickPositionForPlayer(whichPlayer: player, x: number, y: number): void;

/**
 * 设置空格键转向点(指定玩家)  
 * 设置 ${Player} 的空格键转向点为 ${指定点}
 *
 * @remark
 * 按下空格键时镜头转向的位置.
 *
 * @TC_CAMERA
 */
declare function SetCameraQuickPositionLocForPlayer(whichPlayer: player, loc: location): void;
declare function SetCameraQuickPositionLoc(loc: location): void;

/**
 * 停止播放镜头(指定玩家)  
 * 让 ${Player} 停止播放镜头
 *
 * @remark
 * 比如在平移镜头的过程中可用该动作来中断平移.
 *
 * @TC_CAMERA
 */
declare function StopCameraForPlayerBJ(whichPlayer: player): void;

/**
 * 锁定镜头到单位(固定镜头源)(指定玩家)  
 * 锁定 ${Player} 的镜头到 ${单位}, 偏移坐标(${X}, ${Y})
 *
 * @remark
 * 偏移坐标(X,Y)以单位脚底为原点坐标.
 *
 * @TC_CAMERA
 */
declare function SetCameraOrientControllerForPlayerBJ(whichPlayer: player, whichUnit: unit, xoffset: number, yoffset: number): void;

/**
 * 设置镜头平滑参数  
 * 设置镜头平滑参数为 ${Factor}
 *
 * @remark
 * 数值越大,镜头转换越平滑.
 *
 * @TC_CAMERA
 */
declare function CameraSetSmoothingFactorBJ(factor: number): void;

/**
 * 重置镜头平滑参数  
 * 重置镜头平滑参数为游戏默认值
 *
 * @remark
 * 其实就是设置镜头平滑参数为0.
 *
 * @TC_CAMERA
 */
declare function CameraResetSmoothingFactorBJ(): void;

/**
 * 对玩家组显示文本消息(自动限时)  
 * 对 ${玩家组} 发送文本信息: ${文字}
 *
 * @remark
 * 显示时间取决于文字长度.
 *
 * @TC_GAME
 */
declare function DisplayTextToForce(toForce: force, message: string): void;

/**
 * 对玩家组显示文本消息(指定时间)  
 * 对 ${玩家组} 发送显示 ${Time} 秒的文本信息: ${文字}
 *
 * @TC_GAME
 */
declare function DisplayTimedTextToForce(toForce: force, duration: number, message: string): void;

/**
 * 清空文本信息(指定玩家组)  
 * 清空 ${玩家组} 屏幕上的文本信息
 *
 * @TC_GAME
 */
declare function ClearTextMessagesBJ(toForce: force): void;

/**
 * 截取字符串  
 * 截取 ${字符串} 的 ${Start} - ${End} 字节部分
 *
 * @remark
 * 例: 截取''Grunts stink''的2 - 4字节部分
 *
 * @TC_NOTHING
 */
declare function SubStringBJ(source: string, start: number, end: number): string;

/**
 * <1.24> 获取对象的h2i值  
 * 转换 ${Handle} 为整数
 *
 * @remark
 * 创建一个对应该handle的临时密钥,可以在哈希表中作为索引号使用.当该handle被彻底销毁时,密钥会被回收.
 *
 * @TC_HASHTABLE
 */
declare function GetHandleIdBJ(h: handle): number;

/**
 * <1.24> 获取字符串的哈希值  
 * 转换 ${String} 为整数
 *
 * @remark
 * 创建一个对应该字符串的永久密钥,可以在哈希表中作为索引号使用
 *
 * @TC_HASHTABLE
 */
declare function StringHashBJ(s: string): number;

/**
 * 游戏计时(循环)  
 * 每当游戏逝去 ${Time} 秒
 *
 * @remark
 * 从事件开始的那一刻开始计时,直到计时完毕后双重新开始计时.
 *
 * @TC_TIME
 */
declare function TriggerRegisterTimerEventPeriodic(trig: trigger, timeout: number): event;

/**
 * 游戏计时(单次)  
 * 当游戏逝去 ${Time} 秒
 *
 * @remark
 * 从事件开始的那一刻开始计时.
 *
 * @TC_TIME
 */
declare function TriggerRegisterTimerEventSingle(trig: trigger, timeout: number): event;

/**
 * 计时器到期  
 * ${计时器} 到期
 *
 * @remark
 * 当计时器到0时触发该事件. 循环计时器可以多次触发该事件. 使用'事件响应 - 到期的计时器'来获取该计时器.
 *
 * @TC_TIME
 */
declare function TriggerRegisterTimerExpireEventBJ(trig: trigger, t: timer): event;

/**
 * 玩家单位事件  
 * ${Player} 的单位 ${Event}
 *
 * @TC_UNIT
 */
declare function TriggerRegisterPlayerUnitEventSimple(trig: trigger, whichPlayer: player, whichEvent: playerunitevent): event;

/**
 * 任意单位事件  
 * 任意单位 ${Event}
 *
 * @TC_UNIT
 */
declare function TriggerRegisterAnyUnitEventBJ(trig: trigger, whichEvent: playerunitevent): void;

/**
 * 选择单位事件  
 * ${玩家} ${Selects/Deselects} 一个单位
 *
 * @remark
 * 通过'事件回应 - 触发单位' 操作被玩家选择的单位.
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerSelectionEventBJ(trig: trigger, whichPlayer: player, selected: boolean): event;

/**
 * 键盘事件  
 * ${玩家} ${Presses/Releases} ${Key} 
 *
 * @remark
 * 目前游戏只支持'Up/Down/Left/Right'四个方向键.
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerKeyEventBJ(trig: trigger, whichPlayer: player, keType: number, keKey: number): event;

/**
 * 游戏胜利  
 * ${玩家} 胜利后离开游戏
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerEventVictory(trig: trigger, whichPlayer: player): event;

/**
 * 游戏失败  
 * ${玩家} 失败后离开游戏
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerEventDefeat(trig: trigger, whichPlayer: player): event;

/**
 * 离开游戏  
 * ${玩家} 离开游戏
 *
 * @remark
 * 这个事件通过玩家离开游戏来开启.
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerEventLeave(trig: trigger, whichPlayer: player): event;

/**
 * 联盟状态事件(任意状态)  
 * ${玩家} 改变联盟状态设定
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerEventAllianceChanged(trig: trigger, whichPlayer: player): event;

/**
 * 按下Esc键  
 * ${玩家} 按下Esc键(跳过电影)
 *
 * @remark
 * 该事件在玩家按下'Escape'键时触发(可能是玩家要跳过当前所播放的电影).
 *
 * @TC_PLAYER
 */
declare function TriggerRegisterPlayerEventEndCinematic(trig: trigger, whichPlayer: player): event;

/**
 * 游戏时间事件  
 * 当游戏时间 ${Operation} ${时间}
 *
 * @remark
 * 游戏时间采用24小时制.早上从6:00开始,下午从18:00开始.
 *
 * @TC_GAME
 */
declare function TriggerRegisterGameStateEventTimeOfDay(trig: trigger, opcode: limitop, limitval: number): event;

/**
 * 单位进入不规则区域 [R]  
 * 任意单位进入 ${区域}
 *
 * @remark
 * 使用'事件响应 - 进入的单位'来响应进入该区域的单位. 该事件需要在其他触发为其添加.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterEnterRegionSimple(trig: trigger, whichRegion: region): event;

/**
 * 单位离开不规则区域 [R]  
 * 任意单位离开 ${区域}
 *
 * @remark
 * 使用'事件响应 - 离开的单位'来响应离开该区域的单位. 该事件需要在其他触发为其添加.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterLeaveRegionSimple(trig: trigger, whichRegion: region): event;

/**
 * 单位进入矩形区域  
 * 任意单位进入 ${矩形区域}
 *
 * @remark
 * 使用'事件响应 - 进入的单位'来响应进入该区域的单位. 事实上是创建不规则区域，并注册单位进入不规则区域事件,所以之后改动该矩形区域对事件不会产生任何影响.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterEnterRectSimple(trig: trigger, r: rect): event;

/**
 * 单位离开矩形区域  
 * 任意单位离开 ${矩形区域}
 *
 * @remark
 * 使用'事件响应 - 离开的单位'来响应离开该区域的单位. 事实上是创建不规则区域，并注册单位离开不规则区域事件,所以之后改动该矩形区域对事件不会产生任何影响.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterLeaveRectSimple(trig: trigger, r: rect): event;
declare function TriggerRegisterDistanceBetweenUnits(trig: trigger, whichUnit: unit, condition: boolexpr | (() => boolean) | null, range: number): event;

/**
 * 进入指定单位的范围  
 * 任意单位进入 ${范围} 以 ${Unit} 为中心的范围内
 *
 * @remark
 * 通过 '事件响应 - 触发单位' 来获取进入范围的单位.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterUnitInRangeSimple(trig: trigger, range: number, whichUnit: unit): event;

/**
 * 生命值变化  
 * ${指定单位} 的生命值变为 ${Operation} ${Value}
 *
 * @remark
 * 从不成立变为成立时触发该事件. 注意:该参照值在注册事件时即被确定为常量,是不会变动的.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterUnitLifeEvent(trig: trigger, whichUnit: unit, opcode: limitop, limitval: number): event;

/**
 * 魔法值变化  
 * ${指定单位} 的魔法值变为${Operation} ${Value}
 *
 * @remark
 * 从不成立变为成立时触发该事件. 注意:该参照值在注册事件时即被确定为常量,是不会变动的.
 *
 * @TC_UNIT
 */
declare function TriggerRegisterUnitManaEvent(trig: trigger, whichUnit: unit, opcode: limitop, limitval: number): event;

/**
 * 对话框被点击  
 * ${对话框} 被点击
 *
 * @remark
 * 通过 '事件响应 - 被点击的对话框' 操作事件中的对话框.
 *
 * @TC_DIALOG
 */
declare function TriggerRegisterDialogEventBJ(trig: trigger, whichDialog: dialog): event;

/**
 * 英雄技能按钮被点击  
 * 英雄技能按钮被点击
 *
 * @TC_GAME
 */
declare function TriggerRegisterShowSkillEventBJ(trig: trigger): event;

/**
 * 建造建筑按钮被点击  
 * 建造建筑按钮被点击
 *
 * @TC_GAME
 */
declare function TriggerRegisterBuildSubmenuEventBJ(trig: trigger): event;

/**
 * 游戏读档  
 * 读取游戏存档
 *
 * @remark
 * 当游戏读取完毕时,该事件生效.
 *
 * @TC_GAME
 */
declare function TriggerRegisterGameLoadedEventBJ(trig: trigger): event;

/**
 * 游戏存档  
 * 保存游戏存档
 *
 * @remark
 * 在切入保存游戏界面前,该事件生效.
 *
 * @TC_GAME
 */
declare function TriggerRegisterGameSavedEventBJ(trig: trigger): event;
declare function RegisterDestDeathInRegionEnum(): void;

/**
 * 可破坏物在区域内死亡(矩形区域)  
 * 可破坏物在 ${矩形区域} 内死亡
 *
 * @remark
 * 默认该事件只能监视最多64个可破坏物. 可以使用'设置 bj_destInRegionDiesCount'来设置该值. 不建议新手使用该触发.
 *
 * @TC_DESTRUCT
 */
declare function TriggerRegisterDestDeathInRegionEvent(trig: trigger, r: rect): void;

/**
 * 添加天气效果  
 * 给 ${Rect} 添加天气效果: ${Weather Id}
 *
 * @remark
 * 用'最后添加的天气效果'来获得所添加的天气效果.
 *
 * @TC_ENVIRONMENT
 */
declare function AddWeatherEffectSaveLast(where: rect, effectID: number): weathereffect;

/**
 * 最后创建的天气效果  
 * 最后创建的天气效果
 *
 * @remark
 * 最后一个使用'环境 - 创建天气效果'动作创建的天气效果.
 *
 * @TC_LAST
 */
declare function GetLastCreatedWeatherEffect(): weathereffect;

/**
 * 删除天气效果  
 * 删除 ${天气效果}
 *
 * @TC_ENVIRONMENT
 */
declare function RemoveWeatherEffectBJ(whichWeatherEffect: weathereffect): void;

/**
 * 创建地形变化:弹坑  
 * 创建一个持续 ${Duration} 秒的 ${Type} 弹坑变形在 ${指定点} ,半径: ${Radius}深度: ${Depth}
 *
 * @remark
 * 使用'最后创建的地形变化'来获取该变化. 深度可取负数. 永久地形变化在保存游戏时不会被记录.
 *
 * @TC_ENVIRONMENT
 */
declare function TerrainDeformationCraterBJ(duration: number, permanent: boolean, where: location, radius: number, depth: number): terraindeformation;

/**
 * 创建地形变化:波纹  
 * 创建一个持续 ${Duration} 秒的 ${Type} 波纹变形在 ${指定点} ,开始半径: ${Radius} ,结束半径: ${Radius} ,深度: ${Depth} 周期: ${Time} 秒,波间距: ${Distance}
 *
 * @remark
 * 使用'最后创建的地形变化'来获取该变化.
 *
 * @TC_ENVIRONMENT
 */
declare function TerrainDeformationRippleBJ(duration: number, limitNeg: boolean, where: location, startRadius: number, endRadius: number, depth: number, wavePeriod: number, waveWidth: number): terraindeformation;

/**
 * 创建地形变化:冲击波  
 * 创建一个持续 ${Duration} 秒的冲击波变形从 ${Source} 到 ${Target} ,半径: ${Radius} ,深度: ${Depth} ,效果存在时间: ${Delay} 秒
 *
 * @remark
 * 使用'最后创建的地形变化'来获取该变化. 深度可取负数.
 *
 * @TC_ENVIRONMENT
 */
declare function TerrainDeformationWaveBJ(duration: number, source: location, target: location, radius: number, depth: number, trailDelay: number): terraindeformation;

/**
 * 创建地形变化:随机  
 * 创建一个持续 ${Duration} 秒的随机变形变形在 ${指定点} ,半径: ${Radius} 最小深度: ${Minimum} 最大深度: ${Maximum}, 变形间隔: ${Update Interval} 秒
 *
 * @remark
 * 使用'最后创建的地形变化'来获取该变化.
 *
 * @TC_ENVIRONMENT
 */
declare function TerrainDeformationRandomBJ(duration: number, where: location, radius: number, minDelta: number, maxDelta: number, updateInterval: number): terraindeformation;

/**
 * 停止地形变化  
 * 停止 ${Terrain Deformation} ,衰退时间: ${Duration} 秒
 *
 * @remark
 * 地形变化会平滑地过渡到无.
 *
 * @TC_ENVIRONMENT
 */
declare function TerrainDeformationStopBJ(deformation: terraindeformation, duration: number): void;

/**
 * 最后创建的地形变化  
 * 最后创建的地形变化
 *
 * @remark
 * 最后一个由'环境 - 创建地形变化'动作创建的地形变化.
 *
 * @TC_LAST
 */
declare function GetLastCreatedTerrainDeformation(): terraindeformation;

/**
 * 创建闪电效果  
 * 创建一道 ${Type} 闪电效果,从 ${点} 到 ${点}
 *
 * @TC_LIGHTNING
 */
declare function AddLightningLoc(codeName: string, where1: location, where2: location): lightning;

/**
 * 删除闪电效果  
 * 删除 ${Lightning}
 *
 * @TC_LIGHTNING
 */
declare function DestroyLightningBJ(whichBolt: lightning): boolean;

/**
 * 移动闪电效果(指定点)  
 * 移动 ${Lightning} ,使其连接 ${点} 到 ${点}
 *
 * @TC_LIGHTNING
 */
declare function MoveLightningLoc(whichBolt: lightning, where1: location, where2: location): boolean;

/**
 * Alpha通道值  
 * ${Lightning} 的Alpha通道值
 *
 * @remark
 * 取值范围0-1. Alpha通道值为0是完全透明的. 可使用'闪电效果 - 改变颜色'动作来改变Alpha通道值.
 *
 * @TC_LIGHTNING
 */
declare function GetLightningColorABJ(whichBolt: lightning): number;

/**
 * 红颜色值  
 * ${Lightning} 的红颜色值
 *
 * @remark
 * 取值范围0-1. 可使用'闪电效果 - 改变颜色'动作来改变颜色值.
 *
 * @TC_LIGHTNING
 */
declare function GetLightningColorRBJ(whichBolt: lightning): number;

/**
 * 绿颜色值  
 * ${Lightning} 的绿颜色值
 *
 * @remark
 * 取值范围0-1. 可使用'闪电效果 - 改变颜色'动作来改变颜色值.
 *
 * @TC_LIGHTNING
 */
declare function GetLightningColorGBJ(whichBolt: lightning): number;

/**
 * 蓝颜色值  
 * ${Lightning} 的蓝颜色值
 *
 * @remark
 * 取值范围0-1. 可使用'闪电效果 - 改变颜色'动作来改变颜色值.
 *
 * @TC_LIGHTNING
 */
declare function GetLightningColorBBJ(whichBolt: lightning): number;

/**
 * 改变闪电效果颜色  
 * 改变 ${Lightning} 的颜色值为(${Red} ${Green} ${Blue}) Alpha通道值为 ${Alpha}
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 颜色和Alpha通道值取值范围0-1. Alpha通道值为0即完全透明.
 *
 * @TC_LIGHTNING
 */
declare function SetLightningColorBJ(whichBolt: lightning, r: number, g: number, b: number, a: number): boolean;

/**
 * 最后创建的闪电效果  
 * 最后创建的闪电效果
 *
 * @remark
 * 最后一个使用'闪电效果 - 创建'动作创建的闪电效果.
 *
 * @TC_LAST
 */
declare function GetLastCreatedLightningBJ(): lightning;

/**
 * 技能效果路径名  
 * ${技能} 的 ${EffectType} 路径名(序号: ${Index})
 *
 * @remark
 * 返回技能效果的模型路径,不管该效果是否存在.实际上就是技能编辑器中按Ctrl+D看到的文本内容. 该效果有多个模型时,序号表示取哪一个模型,如果该序号对应的文本内容不存在则返回上一序号.
 *
 * @TC_GAME
 */
declare function GetAbilityEffectBJ(abilcode: number, t: effecttype, index: number): string;

/**
 * 技能音效名  
 * ${技能} 的 ${SoundType} 名字
 *
 * @remark
 * 同样,实际上就是技能编辑器中按Ctrl+D看到的文本内容.
 *
 * @TC_GAME
 */
declare function GetAbilitySoundBJ(abilcode: number, t: soundtype): string;

/**
 * 地形悬崖高度(指定点)  
 * ${指定点} 处的地形悬崖高度
 *
 * @remark
 * 悬崖高度:深水区为0, 浅水区为1, 平原为2, 之后每层+1.
 *
 * @TC_ENVIRONMENT
 */
declare function GetTerrainCliffLevelBJ(where: location): number;

/**
 * 指定点地形  
 * ${指定点} 处的地形
 *
 * @TC_ENVIRONMENT
 */
declare function GetTerrainTypeBJ(where: location): number;

/**
 * 地形样式(指定点)  
 * ${指定点} 处的地形样式
 *
 * @TC_ENVIRONMENT
 */
declare function GetTerrainVarianceBJ(where: location): number;

/**
 * 改变地形类型(指定点)  
 * 改变 ${指定点} 处的地形为 ${Terrain Type} ,使用样式: ${Variation} 范围: ${Area} 形状: ${Shape}
 *
 * @remark
 * 地形样式-1表示随机样式. 范围即地形编辑器中的刷子大小.1表示128x128范围
 *
 * @TC_ENVIRONMENT
 */
declare function SetTerrainTypeBJ(where: location, terrainType: number, variation: number, area: number, shape: number): void;

/**
 * 地形通行状态关闭(指定点)  
 * ${指定点} 处的 ${Pathing Type} 通行状态为关闭
 *
 * @remark
 * 指定类型单位不能通行即通行状态为关闭. 如该点不能造建筑就是'建造'通行状态为关闭. 可使用'环境 - 设置地形通行状态'来改变通行状态.
 *
 * @TC_ENVIRONMENT
 */
declare function IsTerrainPathableBJ(where: location, t: pathingtype): boolean;

/**
 * 设置地形通行状态(指定点)  
 * 设置 ${指定点} 处单元点的 ${Pathing} 地形通行状态为: ${On/Off}
 *
 * @remark
 * 例:设置'建造'通行状态为开,则该点可以建造建筑. 一个单元点范围为32x32.
 *
 * @TC_ENVIRONMENT
 */
declare function SetTerrainPathableBJ(where: location, t: pathingtype, flag: boolean): void;

/**
 * 设置水颜色  
 * 设置水颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 100%透明的水是不可见的.
 *
 * @TC_ENVIRONMENT
 */
declare function SetWaterBaseColorBJ(red: number, green: number, blue: number, transparency: number): void;
declare function CreateFogModifierRectSimple(whichPlayer: player, whichFogState: fogstate, r: rect, afterUnits: boolean): fogmodifier;
declare function CreateFogModifierRadiusLocSimple(whichPlayer: player, whichFogState: fogstate, center: location, radius: number, afterUnits: boolean): fogmodifier;

/**
 * 创建可见度修正器(矩形区域)  
 * 创建一个状态为 ${Enabled/Disabled} 的可见度修正器给 ${Player} ,设置 ${Visibility State} 在 ${Region}
 *
 * @remark
 * 会创建可见度修正器.
 *
 * @TC_VISIBILITY
 */
declare function CreateFogModifierRectBJ(enabled: boolean, whichPlayer: player, whichFogState: fogstate, r: rect): fogmodifier;

/**
 * 创建可见度修正器(圆范围)  
 * 创建一个状态为 ${Enabled/Disabled} 的可见度修正器给 ${Player} ,设置 ${Visibility State} 在圆心为 ${指定点} 半径为 ${Radius} 的圆范围
 *
 * @remark
 * 会创建可见度修正器.
 *
 * @TC_VISIBILITY
 */
declare function CreateFogModifierRadiusLocBJ(enabled: boolean, whichPlayer: player, whichFogState: fogstate, center: location, radius: number): fogmodifier;

/**
 * 最后创建的可见度修正器  
 * 最后创建的可见度修正器
 *
 * @remark
 * 最后一个由'可见度 - 创建可见度修正器'动作创建的可见度修正器.
 *
 * @TC_LAST
 */
declare function GetLastCreatedFogModifier(): fogmodifier;

/**
 * 启用战争迷雾  
 * 启用战争迷雾
 *
 * @TC_VISIBILITY
 */
declare function FogEnableOn(): void;

/**
 * 禁用战争迷雾  
 * 禁用战争迷雾
 *
 * @TC_VISIBILITY
 */
declare function FogEnableOff(): void;

/**
 * 启用黑色阴影  
 * 启用黑色阴影
 *
 * @TC_VISIBILITY
 */
declare function FogMaskEnableOn(): void;

/**
 * 禁用黑色阴影  
 * 禁用黑色阴影
 *
 * @TC_VISIBILITY
 */
declare function FogMaskEnableOff(): void;

/**
 * 开启/关闭 昼夜交替  
 * ${On/Off} 昼夜交替
 *
 * @TC_GAME
 */
declare function UseTimeOfDayBJ(flag: boolean): void;

/**
 * 设置迷雾  
 * 迷雾风格: ${Style}, Z轴开始端: ${Z-Start}, Z轴结束端: ${Z-End}, 密度: ${Density} 颜色:(${Red}%, ${Green}%, ${Blue}%)
 *
 * @remark
 * 颜色格式为(红,绿,蓝).
 *
 * @TC_ENVIRONMENT
 */
declare function SetTerrainFogExBJ(style: number, zstart: number, zend: number, density: number, red: number, green: number, blue: number): void;

/**
 * 重置迷雾  
 * 重置迷雾为默认设置
 *
 * @TC_ENVIRONMENT
 */
declare function ResetTerrainFogBJ(): void;

/**
 * 播放圆范围内地形装饰物动画  
 * 播放 ${Animation Name} 动作对所有 ${装饰物类型} 在半径为 ${Radius} 圆心为 ${指定点} 的圆范围内
 *
 * @remark
 * 特殊动画名: 'show', 'hide', 'soundon', 'soundoff'
 *
 * @TC_ANIMATION
 */
declare function SetDoodadAnimationBJ(animName: string, doodadID: number, radius: number, center: location): void;

/**
 * 播放矩形区域内地形装饰物动画  
 * 播放 ${Animation Name} 动作对所有 ${装饰物类型} 在 ${Rect} 内
 *
 * @remark
 * 特殊动画名: 'show', 'hide', 'soundon', 'soundoff'
 *
 * @TC_ANIMATION
 */
declare function SetDoodadAnimationRectBJ(animName: string, doodadID: number, r: rect): void;

/**
 * 添加/删除单位动画附加名  
 * ${Add/Remove} ${Tag} 动画附加名给 ${单位}
 *
 * @remark
 * 比如恶魔猎手添加'alternate'会显示为恶魔形态;农民添加'gold'则为背负黄金形态.
 *
 * @TC_ANIMATION
 */
declare function AddUnitAnimationPropertiesBJ(add: boolean, animProperties: string, whichUnit: unit): void;

/**
 * 创建  
 * 使用图像: ${Image} 大小: ${Size} 创建点: ${指定点} Z轴偏移: ${Z} 图像类型: ${Type}
 *
 * @remark
 * 使用'图像 - 设置永久渲染状态'才能显示图像. 创建点作为图像的左下角位置. 该功能存在Bug,会在图像上和右面多出256象素. 所以需要支持Alpha通道的图像且上和右面最后一行像素为透明才能完美显示.
 *
 * @TC_IMAGE
 */
declare function CreateImageBJ(file: string, size: number, where: location, zOffset: number, imageType: number): image;

/**
 * 显示/隐藏图像  
 * ${Show/Hide} ${Image}
 *
 * @TC_IMAGE
 */
declare function ShowImageBJ(flag: boolean, whichImage: image): void;

/**
 * 改变图像位置(指定点)  
 * 改变 ${Image} 的位置为 ${Position} ,Z轴偏移为 ${Z}
 *
 * @remark
 * 指图像的左下角位置.
 *
 * @TC_IMAGE
 */
declare function SetImagePositionBJ(whichImage: image, where: location, zOffset: number): void;

/**
 * 改变图像颜色  
 * 设置 ${Image} 的颜色值为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_IMAGE
 */
declare function SetImageColorBJ(whichImage: image, red: number, green: number, blue: number, alpha: number): void;

/**
 * 最后创建的图像  
 * 最后创建的图像
 *
 * @remark
 * 最后一个使用'图像 - 创建'动作创建的图像.
 *
 * @TC_LAST
 */
declare function GetLastCreatedImage(): image;

/**
 * 创建地面纹理变化  
 * 创建一个地面纹理变化在 ${指定点} ,使用图像: ${Type} 颜色值:(${Red}%, ${Green}%, ${Blue}%) 透明度${Transparency}% (${Enable/Disable} 暂停状态, ${Enble/Disable} 跳过出生动画)
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的. 使用'地面纹理变化 - 设置永久渲染状态' 来显示创建的纹理变化. 暂停状态表示动画播放完毕后是否继续保留该纹理变化.
 *
 * @TC_UBERSPLAT
 */
declare function CreateUbersplatBJ(where: location, name: string, red: number, green: number, blue: number, alpha: number, forcePaused: boolean, noBirthTime: boolean): ubersplat;

/**
 * 显示/隐藏 地面纹理变化  
 * ${Show/Hide} ${Ubersplat}
 *
 * @TC_UBERSPLAT
 */
declare function ShowUbersplatBJ(flag: boolean, whichSplat: ubersplat): void;

/**
 * 最后创建的地面纹理变化  
 * 最后创建的地面纹理变化
 *
 * @remark
 * 最后一个使用'地面纹理 - 创建'动作创建的纹理变化.
 *
 * @TC_LAST
 */
declare function GetLastCreatedUbersplat(): ubersplat;

/**
 * 播放音效  
 * 播放 ${音效}
 *
 * @remark
 * 音效不能在地图初始化时播放. 注意3D音效必须指定地点播放.
 *
 * @TC_SOUND
 */
declare function PlaySoundBJ(soundHandle: sound): void;

/**
 * 停止音效  
 * 停止播放 ${音效} ${After Fading/Immediately}
 *
 * @TC_SOUND
 */
declare function StopSoundBJ(soundHandle: sound, fadeOut: boolean): void;

/**
 * 设置音效音量  
 * 设置 ${音效} 的音量为 ${Volume}%
 *
 * @TC_SOUND
 */
declare function SetSoundVolumeBJ(soundHandle: sound, volumePercent: number): void;

/**
 * 设置音效播放时间点  
 * 设置播放时间点为 ${Offset} 秒对 ${音效}
 *
 * @remark
 * 音效必须是正在播放的. 不能用于3D音效.
 *
 * @TC_SOUND
 */
declare function SetSoundOffsetBJ(newOffset: number, soundHandle: sound): void;

/**
 * 设置声音截断距离  
 * 设置 ${音效} 的截断距离为 ${数值}
 *
 * @remark
 * 地图距离,玩家镜头距离音源超过该范围则切断声音.
 *
 * @TC_SOUND
 */
declare function SetSoundDistanceCutoffBJ(soundHandle: sound, cutoff: number): void;

/**
 * 设置声音速率  
 * 设置 ${音效} 的速率为 ${数值}
 *
 * @remark
 * 表示正常速率的倍数.
 *
 * @TC_SOUND
 */
declare function SetSoundPitchBJ(soundHandle: sound, pitch: number): void;

/**
 * 设置3D音效位置(指定点)  
 * 设置 ${3D音效} 的播放位置为 ${指定点} Z轴高度为 ${Z}
 *
 * @remark
 * 该动作仅用于3D音效.
 *
 * @TC_SOUND
 */
declare function SetSoundPositionLocBJ(soundHandle: sound, loc: location, z: number): void;

/**
 * 绑定单位  
 * 将 ${3D音效} 绑定到 ${单位}
 *
 * @remark
 * 该动作仅用于3D音效.
 *
 * @TC_SOUND
 */
declare function AttachSoundToUnitBJ(soundHandle: sound, whichUnit: unit): void;
declare function SetSoundConeAnglesBJ(soundHandle: sound, inside: number, outside: number, outsideVolumePercent: number): void;

/**
 * 删除音效  
 * 删除 ${音效}
 *
 * @remark
 * 如果音效正在播放则在播放结束时删除.
 *
 * @TC_SOUND
 */
declare function KillSoundWhenDoneBJ(soundHandle: sound): void;

/**
 * 播放3D音效(指定点)  
 * 播放 ${3D音效} ,音量: ${Volume}% 播放位置: ${指定点} Z轴高度: ${Z}
 *
 * @remark
 * 音效不能在地图初始化时播放. 该动作只能用于播放3D音效.
 *
 * @TC_SOUND
 */
declare function PlaySoundAtPointBJ(soundHandle: sound, volumePercent: number, loc: location, z: number): void;

/**
 * 播放3D音效(跟随单位)  
 * 播放 ${3D音效} ,音量: ${Volume}%, 跟随单位: ${目标单位}
 *
 * @remark
 * 音效不能在地图初始化时播放. 该动作只能用于播放3D音效.
 *
 * @TC_SOUND
 */
declare function PlaySoundOnUnitBJ(soundHandle: sound, volumePercent: number, whichUnit: unit): void;

/**
 * 跳播音效  
 * 播放 ${音效},音量: ${Volume}%,跳过开始 ${Offset} 秒
 *
 * @remark
 * 音效不能在地图初始化时播放.该动作不能用于3D音效.
 *
 * @TC_SOUND
 */
declare function PlaySoundFromOffsetBJ(soundHandle: sound, volumePercent: number, startingOffset: number): void;

/**
 * 播放背景音乐  
 * 播放 ${背景音乐}
 *
 * @TC_SOUND
 */
declare function PlayMusicBJ(musicFileName: string): void;

/**
 * 跳播背景音乐  
 * 播放 ${背景音乐} ,跳过开始 ${Offset} 秒,淡入时间: ${Fade Time} 秒
 *
 * @TC_SOUND
 */
declare function PlayMusicExBJ(musicFileName: string, startingOffset: number, fadeInTime: number): void;

/**
 * 设置背景音乐播放时间点  
 * 设置当前背景音乐的播放时间点为 ${Offset} 秒
 *
 * @TC_SOUND
 */
declare function SetMusicOffsetBJ(newOffset: number): void;

/**
 * 播放主题音乐  
 * 播放 ${Music Theme} 主题音乐
 *
 * @remark
 * 播放主题音乐一次,然后恢复原来的音乐.
 *
 * @TC_SOUND
 */
declare function PlayThematicMusicBJ(musicName: string): void;

/**
 * 跳播主题音乐  
 * 播放 ${Music Theme} 主题音乐,跳过开始 ${Offset} 秒
 *
 * @remark
 * 播放主题音乐一次,然后恢复原来的音乐.
 *
 * @TC_SOUND
 */
declare function PlayThematicMusicExBJ(musicName: string, startingOffset: number): void;

/**
 * 设置主题音乐播放时间点  
 * 设置当前主题音乐播放时间点为 ${Offset} 秒
 *
 * @TC_SOUND
 */
declare function SetThematicMusicOffsetBJ(newOffset: number): void;

/**
 * 停止主题音乐  
 * 停止正在播放的主题音乐
 *
 * @TC_SOUND
 */
declare function EndThematicMusicBJ(): void;

/**
 * 停止背景音乐  
 * 停止背景音乐 ${After Fading/Immediately}
 *
 * @TC_SOUND
 */
declare function StopMusicBJ(fadeOut: boolean): void;

/**
 * 恢复背景音乐  
 * 恢复背景音乐
 *
 * @TC_SOUND
 */
declare function ResumeMusicBJ(): void;

/**
 * 设置背景音乐音量  
 * 设置背景音乐音量为 ${Volume}%
 *
 * @TC_SOUND
 */
declare function SetMusicVolumeBJ(volumePercent: number): void;

/**
 * 音效长度  
 * ${音效} 的长度
 *
 * @remark
 * 单位为秒.
 *
 * @TC_SOUND
 */
declare function GetSoundDurationBJ(soundHandle: sound): number;

/**
 * 音乐长度  
 * ${音乐} 的长度
 *
 * @remark
 * 单位为秒.
 *
 * @TC_SOUND
 */
declare function GetSoundFileDurationBJ(musicFileName: string): number;

/**
 * 最后播放的音效  
 * 最后播放的音效
 *
 * @remark
 * 最后一个由'声音 - 播放音效'或'电影 - 播放单位消息'动作播放的音效.
 *
 * @TC_LAST
 */
declare function GetLastPlayedSound(): sound;

/**
 * 最后播放的音乐  
 * 最后播放的音乐
 *
 * @remark
 * 最后一个由'声音 - 播放音乐'动作播放的音乐.
 *
 * @TC_LAST
 */
declare function GetLastPlayedMusic(): string;

/**
 * 设置多通道音量  
 * 设置 ${Volume Channel} 的音量为 ${Volume}%
 *
 * @TC_SOUND
 */
declare function VolumeGroupSetVolumeBJ(vgroup: volumegroup, percent: number): void;
declare function SetCineModeVolumeGroupsImmediateBJ(): void;

/**
 * 设置电影多通道音量环境  
 * 设置多通道音量为电影模式
 *
 * @TC_SOUND
 */
declare function SetCineModeVolumeGroupsBJ(): void;
declare function SetSpeechVolumeGroupsImmediateBJ(): void;

/**
 * 设置语音多通道音量环境  
 * 设置多通道音量为语音模式
 *
 * @remark
 * 语音模式即电影的播送单位消息功能.
 *
 * @TC_SOUND
 */
declare function SetSpeechVolumeGroupsBJ(): void;
declare function VolumeGroupResetImmediateBJ(): void;

/**
 * 重置多通道音量  
 * 重置所有通道音量为预设值.
 *
 * @TC_SOUND
 */
declare function VolumeGroupResetBJ(): void;
declare function GetSoundIsPlayingBJ(soundHandle: sound): boolean;

/**
 * 等待(声音结束)  
 * 等待直到 ${Sound} 在 ${Time} 秒后结束播放.
 *
 * @remark
 * 该功能只对于当前播放的3D-音效有效. 如果该音效未播放或已经结束, 则该功能无效.
 *
 * @TC_WAIT
 */
declare function WaitForSoundBJ(soundHandle: sound, offset: number): void;

/**
 * 设置背景音乐列表(指定播放)  
 * 设置背景音乐列表为: ${Music} ,播放序号: ${Index}
 *
 * @remark
 * 可指定播放文件或播放目录.
 *
 * @TC_SOUND
 */
declare function SetMapMusicIndexedBJ(musicName: string, index: number): void;

/**
 * 设置背景音乐列表(随机播放)  
 * 设置背景音乐列表为: ${Music} ,随机播放
 *
 * @remark
 * 可指定播放文件或播放目录.
 *
 * @TC_SOUND
 */
declare function SetMapMusicRandomBJ(musicName: string): void;

/**
 * 清空背景音乐列表  
 * 清空背景音乐列表
 *
 * @TC_SOUND
 */
declare function ClearMapMusicBJ(): void;

/**
 * 添加/删除区域音效  
 * ${Add/Remove} ${3D音效} 到 ${地区}
 *
 * @remark
 * 该动作仅用于3D音效.
 *
 * @TC_SOUND
 */
declare function SetStackedSoundBJ(add: boolean, soundHandle: sound, r: rect): void;
declare function StartSoundForPlayerBJ(whichPlayer: player, soundHandle: sound): void;
declare function VolumeGroupSetVolumeForPlayerBJ(whichPlayer: player, vgroup: volumegroup, scale: number): void;

/**
 * 允许/禁止昼夜交替音效  
 * ${Enable/Disable} 昼夜交替音效
 *
 * @TC_SOUND
 */
declare function EnableDawnDusk(flag: boolean): void;
declare function IsDawnDuskEnabled(): boolean;

/**
 * 使用白天环境音效  
 * 使用 ${Theme} 白天环境音效
 *
 * @TC_SOUND
 */
declare function SetAmbientDaySound(inLabel: string): void;

/**
 * 使用夜晚环境音效  
 * 使用 ${Theme} 夜晚环境音效
 *
 * @TC_SOUND
 */
declare function SetAmbientNightSound(inLabel: string): void;

/**
 * 创建特效(指定点)  
 * 在 ${指定点} 创建特效: ${Model File}
 *
 * @TC_SPECIALEFFECT
 */
declare function AddSpecialEffectLocBJ(where: location, modelName: string): effect;

/**
 * 创建特效(绑定单位)  
 * 创建并绑定特效到 ${Attachment Point} 对 ${单位} ,使用模型: ${Model File}
 *
 * @TC_SPECIALEFFECT
 */
declare function AddSpecialEffectTargetUnitBJ(attachPointName: string, targetWidget: widget, modelName: string): effect;

/**
 * 删除特效  
 * 删除 ${Special Effect}
 *
 * @TC_SPECIALEFFECT
 */
declare function DestroyEffectBJ(whichEffect: effect): void;

/**
 * 最后创建的特效  
 * 最后创建的特效
 *
 * @remark
 * 最后一个使用'特殊效果 - 创建特效'动作创建的效果.
 *
 * @TC_LAST
 */
declare function GetLastCreatedEffectBJ(): effect;

/**
 * 物品位置  
 * ${物品} 的位置
 *
 * @remark
 * 会创建点.
 *
 * @TC_ITEM
 */
declare function GetItemLoc(whichItem: item): location;

/**
 * 生命值  
 * ${物品} 的当前生命值
 *
 * @TC_ITEM
 */
declare function GetItemLifeBJ(whichWidget: widget): number;

/**
 * 设置物品生命值  
 * 设置 ${物品} 的生命值为 ${Value}
 *
 * @TC_ITEM
 */
declare function SetItemLifeBJ(whichWidget: widget, life: number): void;

/**
 * 增加经验值  
 * 增加 ${Quantity} 经验值给 ${Hero} , ${Show/Hide} 升级动画
 *
 * @remark
 * 经验值不能倒退.
 *
 * @TC_HERO
 */
declare function AddHeroXPSwapped(xpToAdd: number, whichHero: unit, showEyeCandy: boolean): void;
declare function SetHeroLevelBJ(whichHero: unit, newLevel: number, showEyeCandy: boolean): void;

/**
 * 降低技能等级  
 * 降低 ${技能} 等级对 ${单位}
 *
 * @remark
 * 改变死亡单位的光环技能会导致魔兽崩溃.
 *
 * @TC_UNIT
 */
declare function DecUnitAbilityLevelSwapped(abilcode: number, whichUnit: unit): number;

/**
 * 提升技能等级  
 * 提升 ${技能} 等级对 ${单位}
 *
 * @remark
 * 改变死亡单位的光环技能会导致魔兽崩溃.
 *
 * @TC_UNIT
 */
declare function IncUnitAbilityLevelSwapped(abilcode: number, whichUnit: unit): number;

/**
 * 设置技能等级  
 * 设置 ${技能} 等级对 ${单位} 为 ${Level}
 *
 * @remark
 * 改变死亡单位的光环技能会导致魔兽崩溃.
 *
 * @TC_UNIT
 */
declare function SetUnitAbilityLevelSwapped(abilcode: number, whichUnit: unit, level: number): number;

/**
 * 单位技能等级  
 * ${技能} 的等级对 ${单位}
 *
 * @remark
 * 如果单位没有该技能,则返回0.
 *
 * @TC_UNIT
 */
declare function GetUnitAbilityLevelSwapped(abilcode: number, whichUnit: unit): number;

/**
 * 拥有魔法效果  
 * ${单位} 拥有 ${魔法效果}
 *
 * @TC_UNIT
 */
declare function UnitHasBuffBJ(whichUnit: unit, buffcode: number): boolean;

/**
 * 删除指定魔法效果  
 * 删除 ${魔法效果} 从 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitRemoveBuffBJ(buffcode: number, whichUnit: unit): boolean;

/**
 * 给予物品  
 * 把 ${物品} 给 ${单位}
 *
 * @TC_HERO
 */
declare function UnitAddItemSwapped(whichItem: item, whichHero: unit): boolean;

/**
 * 创建物品给英雄  
 * 创建 ${物品类型} 给 ${单位}
 *
 * @TC_HERO
 */
declare function UnitAddItemByIdSwapped(itemId: number, whichHero: unit): item;

/**
 * 丢弃物品(指定物品)  
 * 丢弃 ${物品} ,从 ${单位} 身上
 *
 * @remark
 * 物品将被丢弃在英雄脚下.
 *
 * @TC_HERO
 */
declare function UnitRemoveItemSwapped(whichItem: item, whichHero: unit): void;

/**
 * 丢弃物品(指定物品栏)  
 * 丢弃物品栏中第 ${Index} 格的物品,从 ${单位} 身上
 *
 * @remark
 * 如果物品存在则会被丢弃在英雄脚下.
 *
 * @TC_HERO
 */
declare function UnitRemoveItemFromSlotSwapped(itemSlot: number, whichHero: unit): item;

/**
 * 创建  
 * 创建 ${物品} 在 ${指定点}
 *
 * @TC_ITEM
 */
declare function CreateItemLoc(itemId: number, loc: location): item;

/**
 * 最后创建的物品  
 * 最后创建的物品
 *
 * @remark
 * 最后一个使用'物品 - 创建'或'英雄 - 创建物品给英雄'动作创建的物品.
 *
 * @TC_LAST
 */
declare function GetLastCreatedItem(): item;

/**
 * 最后丢弃的物品  
 * 最后丢弃的物品
 *
 * @remark
 * 最后一个使用'英雄 - 丢弃物品'动作丢弃的物品.
 *
 * @TC_LAST
 */
declare function GetLastRemovedItem(): item;

/**
 * 移动物品到指定点(立即)(指定点)  
 * 移动 ${物品} 到 ${指定点}
 *
 * @TC_ITEM
 */
declare function SetItemPositionLoc(whichItem: item, loc: location): void;

/**
 * 学习技能  
 * 学习技能
 *
 * @remark
 * 响应'学习技能'单位事件, 指代被学习的技能. 新函数在'技能'类别中.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetLearnedSkillBJ(): number;

/**
 * 允许/禁止经验获取  
 * ${Enable/Disable} ${Hero} 的经验获取
 *
 * @TC_HERO
 */
declare function SuspendHeroXPBJ(flag: boolean, whichHero: unit): void;

/**
 * 设置经验获得率  
 * 设置 ${Player} 的经验获得率为 ${Percent}%
 *
 * @TC_HERO
 */
declare function SetPlayerHandicapXPBJ(whichPlayer: player, handicapPercent: number): void;

/**
 * 经验增长率  
 * ${Player} 的经验增长率
 *
 * @remark
 * 百分比数值, 默认值为100.
 *
 * @TC_PLAYER
 */
declare function GetPlayerHandicapXPBJ(whichPlayer: player): number;

/**
 * 设置生命上限  
 * 设置 ${Player} 的生命障碍为正常的 ${Percent}%
 *
 * @remark
 * 生命上限影响玩家拥有单位的生命最大值. 生命之书并不受生命上限限制,所以对英雄血量可能会有偏差.
 *
 * @TC_PLAYER
 */
declare function SetPlayerHandicapBJ(whichPlayer: player, handicapPercent: number): void;

/**
 * 生命障碍  
 * ${Player} 的生命障碍
 *
 * @remark
 * 百分比数值, 默认值为100.
 *
 * @TC_PLAYER
 */
declare function GetPlayerHandicapBJ(whichPlayer: player): number;

/**
 * 英雄属性  
 * ${Attribute} 对 ${英雄} (${Include/Exclude} 加成)
 *
 * @TC_HERO
 */
declare function GetHeroStatBJ(whichStat: number, whichHero: unit, includeBonuses: boolean): number;
declare function SetHeroStat(whichHero: unit, whichStat: number, value: number): void;

/**
 * 修改英雄属性  
 * 修改 ${Attribute} 对 ${英雄} : ${Modify} ${Value} 点
 *
 * @TC_HERO
 */
declare function ModifyHeroStat(whichStat: number, whichHero: unit, modifyMethod: number, value: number): void;

/**
 * 修改剩余技能点  
 * 修改 ${英雄} 的剩余技能点: ${Modify} ${Value} 点
 *
 * @TC_HERO
 */
declare function ModifyHeroSkillPoints(whichHero: unit, modifyMethod: number, value: number): boolean;
declare function UnitDropItemPointBJ(whichUnit: unit, whichItem: item, x: number, y: number): boolean;

/**
 * 发布丢弃物品命令(指定点)  
 * 命令 ${单位} 丢弃物品 ${物品} 到 ${指定点}
 *
 * @TC_UNIT
 */

/**
 * 发布丢弃物品命令(指定点)  
 * 命令 ${单位} 丢弃物品 ${物品} 到 ${指定点}
 *
 * @TC_UNIT
 */
declare function UnitDropItemPointLoc(whichUnit: unit, whichItem: item, loc: location): boolean;

/**
 * 移动物品到物品栏  
 * 命令 ${单位} 移动 ${物品} 到物品栏第 ${Index} 格
 *
 * @remark
 * 只有当单位持有该物品时才有效.
 *
 * @TC_UNIT
 */

/**
 * 移动物品到物品栏  
 * 命令 ${单位} 移动 ${物品} 到物品栏第 ${Index} 格
 *
 * @remark
 * 只有当单位持有该物品时才有效.
 *
 * @TC_UNIT
 */
declare function UnitDropItemSlotBJ(whichUnit: unit, whichItem: item, slot: number): boolean;

/**
 * 发布给予物品命令  
 * 命令 ${单位} 把 ${物品} 给 ${单位}
 *
 * @TC_UNIT
 */

/**
 * 发布给予物品命令  
 * 命令 ${单位} 把 ${物品} 给 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitDropItemTargetBJ(whichUnit: unit, whichItem: item, target: widget): boolean;

/**
 * 使用物品(对可破坏物)  
 * 命令 ${单位} 使用 ${物品} ,目标: ${可破坏物}
 *
 * @TC_HERO
 */
declare function UnitUseItemDestructable(whichUnit: unit, whichItem: item, target: widget): boolean;

/**
 * 使用物品(指定点)  
 * 命令 ${单位} 使用 ${物品} ,目标点: ${指定点}
 *
 * @TC_HERO
 */
declare function UnitUseItemPointLoc(whichUnit: unit, whichItem: item, loc: location): boolean;

/**
 * 单位持有物品  
 * ${单位} 物品栏第 ${Index} 格的物品
 *
 * @remark
 * 第一个单位格的位置为1.
 *
 * @TC_NOTHING
 */
declare function UnitItemInSlotBJ(whichUnit: unit, itemSlot: number): item;

/**
 * 物品在物品栏的序号 [C]  
 * ${单位} 所持有的 ${物品类型} 的物品栏序号
 *
 * @remark
 * 如果单位没有该类型的物品则返回0
 *
 * @TC_ITEM
 */
declare function GetInventoryIndexOfItemTypeBJ(whichUnit: unit, itemId: number): number;

/**
 * 单位持有物品(指定类型)  
 * ${单位} 所持有的 ${物品类型}
 *
 * @remark
 * 注意：有多个相同物品时，只能获取第一个物品。
 *
 * @TC_NOTHING
 */
declare function GetItemOfTypeFromUnitBJ(whichUnit: unit, itemId: number): item;

/**
 * 持有物品(指定类型)  
 * ${Hero} 拥有 ${物品类型}
 *
 * @TC_HERO
 */
declare function UnitHasItemOfTypeBJ(whichUnit: unit, itemId: number): boolean;

/**
 * 持有物品数量  
 * ${单位} 所持有的物品数量
 *
 * @TC_UNIT
 */
declare function UnitInventoryCount(whichUnit: unit): number;

/**
 * 物品栏格数  
 * ${单位} 的物品栏格数
 *
 * @TC_UNIT
 */
declare function UnitInventorySizeBJ(whichUnit: unit): number;

/**
 * 设置物品无敌/可攻击  
 * 设置 ${物品} ${Invulnerable/Vulnerable}
 *
 * @TC_ITEM
 */
declare function SetItemInvulnerableBJ(whichItem: item, flag: boolean): void;

/**
 * 设置物品死亡是否掉落  
 * 设置 ${物品} ${Drop from/Stay with} 在持有者死亡时
 *
 * @TC_ITEM
 */
declare function SetItemDropOnDeathBJ(whichItem: item, flag: boolean): void;

/**
 * 设置物品可否丢弃  
 * 设置${物品} ${Droppable/Undroppable}
 *
 * @remark
 * 不可掉落物品在被捡起之后就不能移动和丢弃.(但可通过触发实现)
 *
 * @TC_ITEM
 */
declare function SetItemDroppableBJ(whichItem: item, flag: boolean): void;

/**
 * 改变物品所属玩家  
 * 改变 ${物品} 的所属玩家为: ${Player} 并 ${Change/Retain Color}
 *
 * @remark
 * 不是所有物品都能改变颜色. 所属玩家与持有者无关,默认为中立被动玩家.
 *
 * @TC_ITEM
 */
declare function SetItemPlayerBJ(whichItem: item, whichPlayer: player, changeColor: boolean): void;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${物品}
 *
 * @remark
 * 只对在地面的物品有效,不会影响在物品栏中的物品. 单位通过触发得到一个隐藏物品时,会自动显示该物品.
 *
 * @TC_ITEM
 */
declare function SetItemVisibleBJ(show: boolean, whichItem: item): void;

/**
 * 物品隐藏  
 * ${物品} 是隐藏的
 *
 * @remark
 * 单位持有的物品也被认为是隐藏的. 建议使用物品可见
 *
 * @TC_ITEM
 */
declare function IsItemHiddenBJ(whichItem: item): boolean;

/**
 * 随机物品类型  
 * 等级 ${Level} 的随机物品类型
 *
 * @remark
 * 该功能为ROC版函数,使用旧版等级作为参照对象. -1表示任何等级.
 *
 * @TC_NOTHING
 */
declare function ChooseRandomItemBJ(level: number): number;

/**
 * 随机物品类型(指定分类)  
 * 等级 ${Level} 的随机 ${Class} 物品类型
 *
 * @remark
 * 该功能为新版函数,使用新版等级作为参照对象. -1表示任何等级.
 *
 * @TC_NOTHING
 */
declare function ChooseRandomItemExBJ(level: number, whichType: itemtype): number;

/**
 * 随机中立建筑类型  
 * 随机中立建筑类型
 *
 * @TC_NOTHING
 */
declare function ChooseRandomNPBuildingBJ(): number;

/**
 * 随机中立单位类型  
 * 一个等级 ${Level} 的随机中立单位类型
 *
 * @remark
 * -1代表所有等级.
 *
 * @TC_NOTHING
 */
declare function ChooseRandomCreepBJ(level: number): number;

/**
 * 选取矩形区域内物品做动作  
 * 选取 ${矩形区域} 内所有物品 ${做动作}
 *
 * @remark
 * 组动作中可使用'选取物品'来获取对应的物品. 区域内每个物品都会运行一次动作(包括隐藏物品,不包括单位身上的物品). 等待不能在组动作中运行.
 *
 * @TC_ITEM
 */
declare function EnumItemsInRectBJ(r: rect, actionFunc: () => void): void;
declare function RandomItemInRectBJEnum(): void;

/**
 * 矩形区域内随机物品(指定条件)  
 * ${矩形区域} 内满足 ${条件} 的一个随机物品
 *
 * @remark
 * 使用'匹配物品'来指代条件中用于比较的物品.
 *
 * @TC_NOTHING
 */
declare function RandomItemInRectBJ(r: rect, filter: boolexpr | (() => boolean) | null): item;

/**
 * 矩形区域内随机物品  
 * ${矩形区域} 内随机选取的一个物品
 *
 * @TC_NOTHING
 */
declare function RandomItemInRectSimpleBJ(r: rect): item;

/**
 * 物品状态检查  
 * ${物品} 是 ${Status} 的
 *
 * @TC_ITEM
 */
declare function CheckItemStatus(whichItem: item, status: number): boolean;

/**
 * 物品类型状态检查  
 * ${物品类型} 是 ${Status} 的
 *
 * @TC_ITEM
 */
declare function CheckItemcodeStatus(itemId: number, status: number): boolean;

/**
 * 转换单位类型为命令ID  
 * 转换 ${单位类型} 为命令ID
 *
 * @TC_CONVERSION
 */
declare function UnitId2OrderIdBJ(unitId: number): number;

/**
 * 转换字符串为单位类型  
 * 转换 ${字符串} 为单位类型
 *
 * @TC_CONVERSION
 */
declare function String2UnitIdBJ(unitIdString: string): number;

/**
 * 转换单位类型为字符串  
 * 转换 ${单位类型} 为字符串
 *
 * @TC_CONVERSION
 */
declare function UnitId2StringBJ(unitId: number): string;

/**
 * 转换命令字符串为命令ID  
 * 转换 ${字符串} 为命令ID
 *
 * @remark
 * 如''harvest'', ''move'', ''smart'', ''attack''都是命令字符串.
 *
 * @TC_CONVERSION
 */
declare function String2OrderIdBJ(orderIdString: string): number;

/**
 * 转换命令ID为字符串  
 * 转换 ${Order} 为命令字符串
 *
 * @remark
 * 如''harvest'', ''move'', ''smart'', ''attack''都是命令字符串.
 *
 * @TC_CONVERSION
 */
declare function OrderId2StringBJ(orderId: number): string;

/**
 * 发布的命令ID  
 * 发布的命令ID
 *
 * @remark
 * 响应'发布命令'单位事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetIssuedOrderIdBJ(): number;

/**
 * 凶手单位  
 * 凶手单位
 *
 * @remark
 * 响应'死亡'单位事件. 如果不是被单位所杀(比如负数邪恶光环)则返回null.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetKillingUnitBJ(): unit;
declare function CreateUnitAtLocSaveLast(id: player, unitid: number, loc: location, face: number): unit;

/**
 * 最后创建的单位  
 * 最后创建的单位
 *
 * @remark
 * 最后一个使用'单位 - 创建'动作创建的单位.
 *
 * @TC_LAST
 */
declare function GetLastCreatedUnit(): unit;

/**
 * 创建单位(面向角度)  
 * 创建 ${Number} 个 ${单位} 给 ${Player} 在 ${指定点} ,面向角度为 ${Direction} 度
 *
 * @remark
 * 面向角度采用角度制,0度为正东方向,90度为正北方向. 使用'最后创建的单位组'来获取创建的所有单位. 使用'最后创建的单位'来获取创建的单个单位.
 *
 * @TC_UNIT
 */
declare function CreateNUnitsAtLoc(count: number, unitId: number, whichPlayer: player, loc: location, face: number): group;

/**
 * 创建单位(面向点)  
 * 创建 ${Number} ${单位} 给 ${Player} 在 ${指定点} ,面向 ${指定点}
 *
 * @remark
 * 使用'最后创建的单位组'来获取创建的所有单位. 使用'最后创建的单位'来获取创建的单个单位.
 *
 * @TC_UNIT
 */
declare function CreateNUnitsAtLocFacingLocBJ(count: number, unitId: number, whichPlayer: player, loc: location, lookAt: location): group;
declare function GetLastCreatedGroupEnum(): void;

/**
 * 最后创建的单位组  
 * 最后创建的单位组
 *
 * @remark
 * 最后一批通过'单位 - 创建'动作创建的单位.
 *
 * @TC_LAST
 */
declare function GetLastCreatedGroup(): group;

/**
 * 创建尸体  
 * 创建一个 ${单位} 的尸体给 ${Player} 在 ${指定点}
 *
 * @remark
 * 不是所有单位都有尸体形态. 使用'最后创建的单位'来获取该尸体.
 *
 * @TC_UNIT
 */
declare function CreateCorpseLocBJ(unitid: number, whichPlayer: player, loc: location): unit;

/**
 * 暂停尸体腐烂  
 * ${Suspend/Resume} 尸体腐烂对 ${单位}
 *
 * @remark
 * 只对已完成死亡动作的尸体有效.
 *
 * @TC_UNIT
 */
declare function UnitSuspendDecayBJ(suspend: boolean, whichUnit: unit): void;
declare function DelayedSuspendDecayStopAnimEnum(): void;
declare function DelayedSuspendDecayBoneEnum(): void;
declare function DelayedSuspendDecayFleshEnum(): void;
declare function DelayedSuspendDecay(): void;
declare function DelayedSuspendDecayCreate(): void;

/**
 * 创建永久性尸体  
 * 创建一个 ${Style} ${单位} 尸体给 ${Player} 在 ${指定点} 面向角度为 ${Direction} 度
 *
 * @remark
 * 肉态尸体经常会自动变为骨态尸体.
 *
 * @TC_UNIT
 */
declare function CreatePermanentCorpseLocBJ(style: number, unitid: number, whichPlayer: player, loc: location, facing: number): unit;

/**
 * 属性  
 * ${Property} 对于 ${单位}
 *
 * @TC_UNIT
 */
declare function GetUnitStateSwap(whichState: unitstate, whichUnit: unit): number;
declare function GetUnitStatePercent(whichUnit: unit, whichState: unitstate, whichMaxState: unitstate): number;

/**
 * 生命百分比  
 * ${单位} 的生命百分比
 *
 * @TC_UNIT
 */
declare function GetUnitLifePercent(whichUnit: unit): number;

/**
 * 魔法百分比  
 * ${单位} 的魔法百分比
 *
 * @TC_UNIT
 */
declare function GetUnitManaPercent(whichUnit: unit): number;

/**
 * 选择单位(所有玩家)  
 * 命令所有玩家选择 ${单位}
 *
 * @remark
 * 使玩家取消选择所有已选单位,并选择该单位.
 *
 * @TC_UNITSEL
 */
declare function SelectUnitSingle(whichUnit: unit): void;
declare function SelectGroupBJEnum(): void;

/**
 * 选择单位组(所有玩家)  
 * 命令所有玩家选择 ${单位组}
 *
 * @remark
 * 使所有玩家取消选择所有单位,并选择单位组中最多12个单位.
 *
 * @TC_UNITSEL
 */
declare function SelectGroupBJ(g: group): void;

/**
 * 添加选择单位(所有玩家)  
 * 命令所有玩家添加选择 ${单位}
 *
 * @TC_UNITSEL
 */
declare function SelectUnitAdd(whichUnit: unit): void;

/**
 * 取消选择单位(所有玩家)  
 * 命令所有玩家取消选择 ${单位}
 *
 * @TC_UNITSEL
 */
declare function SelectUnitRemove(whichUnit: unit): void;

/**
 * 清空选择(指定玩家)  
 * 清空 ${Player} 的选择
 *
 * @remark
 * 使玩家取消选择所有已选单位.
 *
 * @TC_UNITSEL
 */
declare function ClearSelectionForPlayer(whichPlayer: player): void;

/**
 * 选择单位(指定玩家)  
 * 选择 ${单位} 对 ${Player}
 *
 * @remark
 * 使玩家取消选择所有单位,并选择该单位.
 *
 * @TC_UNITSEL
 */
declare function SelectUnitForPlayerSingle(whichUnit: unit, whichPlayer: player): void;

/**
 * 选择单位组(指定玩家)  
 * 选择 ${单位组} 对 ${Player}
 *
 * @remark
 * 使玩家取消选择所有单位,并选择单位组中最多12个单位.
 *
 * @TC_UNITSEL
 */
declare function SelectGroupForPlayerBJ(g: group, whichPlayer: player): void;

/**
 * 添加选择单位(指定玩家)  
 * 添加选择 ${单位} 对 ${Player}
 *
 * @remark
 * 使玩家添加选择该单位.
 *
 * @TC_UNITSEL
 */
declare function SelectUnitAddForPlayer(whichUnit: unit, whichPlayer: player): void;

/**
 * 取消选择单位(指定玩家)  
 * 取消选择 ${单位} 对 ${Player}
 *
 * @remark
 * 使玩家取消选择该单位.
 *
 * @TC_UNITSEL
 */
declare function SelectUnitRemoveForPlayer(whichUnit: unit, whichPlayer: player): void;

/**
 * 设置生命值(指定值)  
 * 设置 ${单位} 的生命值为 ${Value}
 *
 * @TC_UNIT
 */
declare function SetUnitLifeBJ(whichUnit: unit, newValue: number): void;

/**
 * 设置魔法值(指定值)  
 * 设置 ${单位} 的魔法值为 ${Value}
 *
 * @TC_UNIT
 */
declare function SetUnitManaBJ(whichUnit: unit, newValue: number): void;

/**
 * 设置生命值(百分比)  
 * 设置 ${单位} 的生命值为 ${Percent}%
 *
 * @TC_UNIT
 */
declare function SetUnitLifePercentBJ(whichUnit: unit, percent: number): void;

/**
 * 设置魔法值(百分比)  
 * 设置 ${单位} 的魔法值为 ${Percent}%
 *
 * @TC_UNIT
 */
declare function SetUnitManaPercentBJ(whichUnit: unit, percent: number): void;

/**
 * 单位生命值不大于零  
 * ${单位} 生命值不大于零
 *
 * @TC_UNIT
 */
declare function IsUnitDeadBJ(whichUnit: unit): boolean;

/**
 * 单位生命值大于零  
 * ${单位} 生命值大于零
 *
 * @TC_UNIT
 */
declare function IsUnitAliveBJ(whichUnit: unit): boolean;
declare function IsUnitGroupDeadBJEnum(): void;

/**
 * 单位组中所有单位死亡  
 * ${单位组} 中所有单位死亡
 *
 * @TC_UNITGROUP
 */
declare function IsUnitGroupDeadBJ(g: group): boolean;
declare function IsUnitGroupEmptyBJEnum(): void;

/**
 * 单位组为空  
 * ${单位组} 为空
 *
 * @TC_UNITGROUP
 */
declare function IsUnitGroupEmptyBJ(g: group): boolean;
declare function IsUnitGroupInRectBJEnum(): void;

/**
 * 单位组中单位在矩形区域内  
 * ${单位组} 中所有单位在 ${矩形区域} 内
 *
 * @TC_UNITGROUP
 */
declare function IsUnitGroupInRectBJ(g: group, r: rect): boolean;

/**
 * 单位隐藏  
 * ${单位} 处于隐藏状态
 *
 * @remark
 * 可通过'单位 - 隐藏'动作来析藏单位. 运输机,灵魂之球,祭坛中的单位都被认为是隐藏状态.
 *
 * @TC_UNIT
 */
declare function IsUnitHiddenBJ(whichUnit: unit): boolean;

/**
 * 隐藏  
 * 隐藏 ${单位}
 *
 * @remark
 * 使用'单位 - 显示'来显示该单位. 隐藏单位不会被'区域内单位'所选取.
 *
 * @TC_UNIT
 */
declare function ShowUnitHide(whichUnit: unit): void;

/**
 * 显示  
 * 显示 ${单位}
 *
 * @remark
 * 使用'单位 - 隐藏'来显示该单位. 隐藏单位不会被'区域内单位'所选取.
 *
 * @TC_UNIT
 */
declare function ShowUnitShow(whichUnit: unit): void;
declare function IssueHauntOrderAtLocBJFilter(): boolean;
declare function IssueHauntOrderAtLocBJ(whichPeon: unit, loc: location): boolean;

/**
 * 发布建造命令(指定点)  
 * 命令 ${单位} 建造 ${单位类型} 在 ${指定点}
 *
 * @TC_UNIT
 */

/**
 * 发布建造命令(指定点)  
 * 命令 ${单位} 建造 ${单位类型} 在 ${指定点}
 *
 * @TC_UNIT
 */
declare function IssueBuildOrderByIdLocBJ(whichPeon: unit, unitId: number, loc: location): boolean;

/**
 * 发布训练/升级命令  
 * 命令 ${单位} 建造/升级为 ${单位类型}
 *
 * @remark
 * 该升级是指A单位升级为B单位,而不是科技升级.
 *
 * @TC_UNIT
 */

/**
 * 发布训练/升级命令  
 * 命令 ${单位} 建造/升级为 ${单位类型}
 *
 * @remark
 * 该升级是指A单位升级为B单位,而不是科技升级.
 *
 * @TC_UNIT
 */
declare function IssueTrainOrderByIdBJ(whichUnit: unit, unitId: number): boolean;

/**
 * 发布发布训练/升级命令  
 * 命令 ${单位组} 训练/升级为 ${单位类型}
 *
 * @remark
 * 最多只能对单位组中12个单位发布命令.
 *
 * @TC_UNITGROUP
 */
declare function GroupTrainOrderByIdBJ(g: group, unitId: number): boolean;

/**
 * 发布研究科技命令  
 * 命令 ${单位} 研究 ${Tech-Type}
 *
 * @TC_UNIT
 */

/**
 * 发布研究科技命令  
 * 命令 ${单位} 研究 ${Tech-Type}
 *
 * @TC_UNIT
 */
declare function IssueUpgradeOrderByIdBJ(whichUnit: unit, techId: number): boolean;

/**
 * 被攻击单位  
 * 被攻击单位
 *
 * @remark
 * 响应'被攻击'单位事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetAttackedUnitBJ(): unit;

/**
 * 改变单位飞行高度  
 * 改变 ${单位} 的飞行高度为 ${数值} ,变换速率: ${数值}
 *
 * @remark
 * 飞行单位可以直接改变飞行高度. 其他单位通过添加/删除 替换为飞行单位的变身技能(如乌鸦形态)之后,也能改变飞行高度.
 *
 * @TC_ANIMATION
 */
declare function SetUnitFlyHeightBJ(whichUnit: unit, newHeight: number, rate: number): void;

/**
 * 改变单位转身速度  
 * 改变 ${单位} 的转身速度为 ${Value}
 *
 * @remark
 * 转身速度表示单位改变面向方向时的速度，数值(0-1)越小表示转身越慢，为0则无法转身。
 *
 * @TC_ANIMATION
 */
declare function SetUnitTurnSpeedBJ(whichUnit: unit, turnSpeed: number): void;

/**
 * 改变单位转向角度(角度制)  
 * 改变 ${单位} 的转向角度为 ${数值} 度
 *
 * @remark
 * 设置单位转身时的转向角度. 数值越大转向幅度越大. 大于360度的角将作为359度角处理.
 *
 * @TC_ANIMATION
 */
declare function SetUnitPropWindowBJ(whichUnit: unit, propWindow: number): void;

/**
 * 当前转向角度(角度制)  
 * ${单位} 的当前转向角度
 *
 * @remark
 * 单位转身时的转向角度. 数值越大转向幅度越大.
 *
 * @TC_UNIT
 */
declare function GetUnitPropWindowBJ(whichUnit: unit): number;

/**
 * 默认转向角度  
 * ${单位} 的默认转向角度
 *
 * @remark
 * 单位转身时的转向角度. 数值越大转向幅度越大.
 *
 * @TC_UNIT
 */
declare function GetUnitDefaultPropWindowBJ(whichUnit: unit): number;

/**
 * 改变单位混合时间  
 * 改变 ${单位} 的混合时间为 ${数值}
 *
 * @remark
 * 单位动画图像混合时间. 决定身体部件连接的快慢,比如攻击时手臂挥舞的速度. 默认值0.15,增大该值会导致动作僵硬化.
 *
 * @TC_ANIMATION
 */
declare function SetUnitBlendTimeBJ(whichUnit: unit, blendTime: number): void;

/**
 * 设置主动攻击范围  
 * 设置 ${单位} 的主动攻击范围为 ${数值}
 *
 * @TC_UNIT
 */
declare function SetUnitAcquireRangeBJ(whichUnit: unit, acquireRange: number): void;

/**
 * 设置单位夜晚睡眠  
 * 设置 ${单位} ${Sleep/Remain Awake} 在夜晚
 *
 * @remark
 * 只对中立单位有效. 并不影响催眠魔法.
 *
 * @TC_UNIT
 */
declare function UnitSetCanSleepBJ(whichUnit: unit, canSleep: boolean): void;

/**
 * 允许夜晚睡眠  
 * ${单位} 会在夜晚进入睡眠
 *
 * @remark
 * 中立生物才会睡眠.
 *
 * @TC_UNIT
 */
declare function UnitCanSleepBJ(whichUnit: unit): boolean;

/**
 * 叫醒  
 * 叫醒 ${单位}
 *
 * @remark
 * 不影响催眠魔法效果.
 *
 * @TC_UNIT
 */
declare function UnitWakeUpBJ(whichUnit: unit): void;

/**
 * 正在睡眠  
 * ${单位} 正在睡眠
 *
 * @remark
 * 中立生物才会睡眠. 不包括催眠魔法.
 *
 * @TC_UNIT
 */
declare function UnitIsSleepingBJ(whichUnit: unit): boolean;
declare function WakePlayerUnitsEnum(): void;
declare function WakePlayerUnits(whichPlayer: player): void;

/**
 * 允许/禁止 中立生物睡眠  
 * ${Enable/Disable} 中立生物睡眠
 *
 * @remark
 * 只影响夜晚的睡眠. 不影响催眠魔法.
 *
 * @TC_PLAYER
 */
declare function EnableCreepSleepBJ(enable: boolean): void;

/**
 * 设置警报开启/关闭  
 * 设置警报对 ${单位} ${On/Off}
 *
 * @remark
 * 只作用于建筑.
 *
 * @TC_UNIT
 */
declare function UnitGenerateAlarms(whichUnit: unit, generate: boolean): boolean;

/**
 * 开启警报  
 * ${单位} 处于开启警报状态
 *
 * @TC_UNIT
 */
declare function DoesUnitGenerateAlarms(whichUnit: unit): boolean;
declare function PauseAllUnitsBJEnum(): void;

/**
 * 暂停/恢复 所有单位  
 * ${Pause/Unpause} 所有单位
 *
 * @remark
 * 该动作只作用于当前存在于地图的单位. 对于之后创建或复活的单位并不会受到影响.
 *
 * @TC_UNIT
 */
declare function PauseAllUnitsBJ(pause: boolean): void;

/**
 * 暂停/恢复  
 * ${Pause/Unpause} ${单位}
 *
 * @TC_UNIT
 */
declare function PauseUnitBJ(pause: boolean, whichUnit: unit): void;

/**
 * 单位暂停  
 * ${单位} 处于暂停状态
 *
 * @TC_UNIT
 */
declare function IsUnitPausedBJ(whichUnit: unit): boolean;

/**
 * 暂停/恢复生命周期  
 * ${Pause/Unpause} ${单位} 的生命周期
 *
 * @remark
 * 只有召唤单位有生命周期.
 *
 * @TC_UNIT
 */
declare function UnitPauseTimedLifeBJ(flag: boolean, whichUnit: unit): void;

/**
 * 设置生命周期  
 * 设置 ${Duration} 秒 ${Buff Type} 类型的生命周期对 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitApplyTimedLifeBJ(duration: number, buffId: number, whichUnit: unit): void;

/**
 * 共享视野  
 * ${Grant/Deny} 共享 ${单位} 的视野对 ${Player}
 *
 * @TC_UNIT
 */
declare function UnitShareVisionBJ(share: boolean, whichUnit: unit, whichPlayer: player): void;

/**
 * 删除魔法效果(指定类别)  
 * 删除 ${Buff Type} 魔法效果从 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitRemoveBuffsBJ(buffType: number, whichUnit: unit): void;

/**
 * 删除魔法效果(详细类别)  
 * 删除 ${Buff Type} ${Buff Resist} Buff从 ${单位}(${Include/Exclude} 生命周期, ${Include/Exclude} 光环)
 *
 * @remark
 * buff性质选项第4项为无效选项, 仅为兼容而保留.
 *
 * @TC_UNIT
 */
declare function UnitRemoveBuffsExBJ(polarity: number, resist: number, whichUnit: unit, bTLife: boolean, bAura: boolean): void;

/**
 * 拥有Buff数量  
 * ${Buff Type} ${Buff Resist} Buff数量在 ${单位} 身上(${Include/Exclude} 生命周期, ${Include/Exclude} 光环)
 *
 * @TC_UNIT
 */
declare function UnitCountBuffsExBJ(polarity: number, resist: number, whichUnit: unit, bTLife: boolean, bAura: boolean): number;

/**
 * 删除技能  
 * 删除 ${技能} 从 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitRemoveAbilityBJ(abilityId: number, whichUnit: unit): boolean;

/**
 * 添加技能  
 * 添加 ${技能} 给 ${单位}
 *
 * @TC_UNIT
 */
declare function UnitAddAbilityBJ(abilityId: number, whichUnit: unit): boolean;

/**
 * 删除类别  
 * 删除 ${Classification} 类别从 ${单位}
 *
 * @remark
 * 并非所有类别都是可以删除的,建议使用新函数.
 *
 * @TC_UNIT
 */
declare function UnitRemoveTypeBJ(whichType: unittype, whichUnit: unit): boolean;

/**
 * 添加类别  
 * 添加 ${Classification} 类别到 ${单位}
 *
 * @remark
 * 并非所有类别都是可以添加的,建议使用新函数.
 *
 * @TC_UNIT
 */
declare function UnitAddTypeBJ(whichType: unittype, whichUnit: unit): boolean;
declare function UnitMakeAbilityPermanentBJ(permanent: boolean, abilityId: number, whichUnit: unit): boolean;

/**
 * 设置死亡方式  
 * 设置 ${单位} ${Explode/Die Normally} 在死亡时
 *
 * @TC_UNIT
 */
declare function SetUnitExplodedBJ(whichUnit: unit, exploded: boolean): void;

/**
 * 爆炸  
 * 使 ${单位} 爆炸而死
 *
 * @remark
 * 爆炸死亡不会留下尸体.
 *
 * @TC_UNIT
 */
declare function ExplodeUnitBJ(whichUnit: unit): void;

/**
 * 运输单位  
 * 运输单位
 *
 * @remark
 * 响应'被装载'单位事件.指代作为载体的单位.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetTransportUnitBJ(): unit;

/**
 * 被装载单位  
 * 被装载单位
 *
 * @remark
 * 响应'被装载'单位事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetLoadedUnitBJ(): unit;

/**
 * 被指定单位装载  
 * ${单位} 被 ${运输机} 装载中
 *
 * @TC_UNIT
 */
declare function IsUnitInTransportBJ(whichUnit: unit, whichTransport: unit): boolean;

/**
 * 被装载  
 * ${单位} 被装载中
 *
 * @remark
 * 被飞艇,船等有运输功能的单位装载.
 *
 * @TC_UNIT
 */
declare function IsUnitLoadedBJ(whichUnit: unit): boolean;

/**
 * 单位是镜像  
 * ${单位} 是镜像单位
 *
 * @TC_UNIT
 */
declare function IsUnitIllusionBJ(whichUnit: unit): boolean;

/**
 * 替换  
 * 将 ${单位} 替换为 ${单位类型} 使用 ${Property Usage} 生命和魔法
 *
 * @remark
 * 使用'最后替换的单位'来获取该单位. 如果是不死族金矿被替换,经常还会留下一个普通的金矿. 实际上就是创建加删除单位
 *
 * @TC_UNIT
 */
declare function ReplaceUnitBJ(whichUnit: unit, newUnitId: number, unitStateMethod: number): unit;

/**
 * 最后替换的单位  
 * 最后替换的单位
 *
 * @remark
 * 最后一个使用'单位 - 替换'替换的单位.
 *
 * @TC_LAST
 */
declare function GetLastReplacedUnitBJ(): unit;

/**
 * 移动单位面向角度(立即)  
 * 立即移动 ${单位} 到 ${指定点} ,面向角度 ${Direction} 度
 *
 * @remark
 * 建议使用'移动单位'+'设置面向角度'动作. 面向角度采用角度制,0度为正东方向,90度为正北方向.
 *
 * @TC_UNIT
 */
declare function SetUnitPositionLocFacingBJ(whichUnit: unit, loc: location, facing: number): void;

/**
 * 移动单位面向点(立即)  
 * 立即移动 ${单位} 到 ${指定点} ,并面向 ${指定点}
 *
 * @remark
 * 建议使用'移动单位'+'设置面向角度'动作.
 *
 * @TC_UNIT
 */
declare function SetUnitPositionLocFacingLocBJ(whichUnit: unit, loc: location, lookAt: location): void;

/**
 * 添加物品(指定市场)  
 * 添加 ${物品类型} 到 ${Marketplace} 并设置库存量: ${Count} 最大库存量: ${Max}
 *
 * @remark
 * 只影响有'出售物品'技能的单位.
 *
 * @TC_NEUTRALBUILDING
 */
declare function AddItemToStockBJ(itemId: number, whichUnit: unit, currentStock: number, stockMax: number): void;

/**
 * 添加单位(指定市场)  
 * 添加 ${单位类型} 到 ${Marketplace} 并设置库存量: ${Count} 最大库存量: ${Max}
 *
 * @remark
 * 只影响有'出售单位'技能的单位.
 *
 * @TC_NEUTRALBUILDING
 */
declare function AddUnitToStockBJ(unitId: number, whichUnit: unit, currentStock: number, stockMax: number): void;

/**
 * 删除物品(指定市场)  
 * 删除 ${物品类型} 从 ${Marketplace}
 *
 * @remark
 * 只影响有'出售物品'技能的单位
 *
 * @TC_NEUTRALBUILDING
 */
declare function RemoveItemFromStockBJ(itemId: number, whichUnit: unit): void;

/**
 * 删除单位(指定市场)  
 * 删除 ${单位类型} 从 ${Marketplace}
 *
 * @remark
 * 只影响有'出售单位'技能的单位.
 *
 * @TC_NEUTRALBUILDING
 */
declare function RemoveUnitFromStockBJ(unitId: number, whichUnit: unit): void;

/**
 * 允许/禁止 人口占用  
 * ${Enable/Disable} ${单位} 的人口占用
 *
 * @TC_UNIT
 */
declare function SetUnitUseFoodBJ(enable: boolean, whichUnit: unit): void;

/**
 * 伤害区域  
 * 命令 ${单位} 在 ${Seconds} 秒后对半径为 ${Size} 圆心为 ${指定点} 的范围造成${Amount} 点伤害,攻击类型: ${AttackType} 伤害类型: ${DamageType}
 *
 * @remark
 * 该动作不会打断单位动作. 由该动作伤害/杀死单位同样正常触发'受到伤害'和'死亡'单位事件.
 *
 * @TC_UNIT
 */

/**
 * 伤害区域  
 * 命令 ${单位} 在 ${Seconds} 秒后对半径为 ${Size} 圆心为 ${指定点} 的范围造成${Amount} 点伤害,攻击类型: ${AttackType} 伤害类型: ${DamageType}
 *
 * @remark
 * 该动作不会打断单位动作. 由该动作伤害/杀死单位同样正常触发'受到伤害'和'死亡'单位事件.
 *
 * @TC_UNIT
 */
declare function UnitDamagePointLoc(whichUnit: unit, delay: number, radius: number, loc: location, amount: number, whichAttack: attacktype, whichDamage: damagetype): boolean;

/**
 * 伤害目标  
 * 命令 ${单位} 对 ${Target} 造成 ${Amount} 点伤害,攻击类型: ${AttackType} 伤害类型: ${DamageType}
 *
 * @remark
 * 该动作不会打断单位动作. 由该动作伤害/杀死单位同样正常触发'受到伤害'和'死亡'单位事件.
 *
 * @TC_UNIT
 */

/**
 * 伤害目标  
 * 命令 ${单位} 对 ${Target} 造成 ${Amount} 点伤害,攻击类型: ${AttackType} 伤害类型: ${DamageType}
 *
 * @remark
 * 该动作不会打断单位动作. 由该动作伤害/杀死单位同样正常触发'受到伤害'和'死亡'单位事件.
 *
 * @TC_UNIT
 */
declare function UnitDamageTargetBJ(whichUnit: unit, target: unit, amount: number, whichAttack: attacktype, whichDamage: damagetype): boolean;

/**
 * 创建可破坏物  
 * 创建 ${可破坏物类型} 在 ${指定点} ,面向角度: ${Direction} 尺寸缩放: ${Scale} 样式: ${Variation}
 *
 * @remark
 * 面向角度采用角度制,0度为正东方向,90度为正北方向. 使用'最后创建的可破坏物'来获取创建的物体.
 *
 * @TC_DESTRUCT
 */
declare function CreateDestructableLoc(objectid: number, loc: location, facing: number, scale: number, variation: number): destructable;

/**
 * 创建可破坏物(死亡)  
 * 创建死亡的 ${可破坏物类型} 在 ${指定点} ,面向角度: ${Direction} 尺寸缩放: ${Scale} 样式: ${Variation}
 *
 * @remark
 * 面向角度采用角度制,0度为正东方向,90度为正北方向. 使用'最后创建的可破坏物'来获取创建的物体.
 *
 * @TC_DESTRUCT
 */
declare function CreateDeadDestructableLocBJ(objectid: number, loc: location, facing: number, scale: number, variation: number): destructable;

/**
 * 最后创建的可破坏物  
 * 最后创建的可破坏物
 *
 * @remark
 * 最后一个使用 '可破坏物 - 创建'动作创建的可破坏物.
 *
 * @TC_LAST
 */
declare function GetLastCreatedDestructable(): destructable;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${可破坏物}
 *
 * @remark
 * 隐藏的可破坏物不被显示,但仍影响通行和视线.
 *
 * @TC_DESTRUCT
 */
declare function ShowDestructableBJ(flag: boolean, d: destructable): void;

/**
 * 设置无敌/可攻击  
 * 设置 ${可破坏物} ${Invulnerable/Vulnerable}
 *
 * @TC_DESTRUCT
 */
declare function SetDestructableInvulnerableBJ(d: destructable, flag: boolean): void;

/**
 * 物件无敌  
 * ${物件} 是无敌的
 *
 * @TC_DESTRUCT
 */
declare function IsDestructableInvulnerableBJ(d: destructable): boolean;

/**
 * 可破坏物位置  
 * ${可破坏物} 的位置
 *
 * @remark
 * 会创建点.
 *
 * @TC_DESTRUCT
 */
declare function GetDestructableLoc(whichDestructable: destructable): location;

/**
 * 选取矩形区域内可破坏物做动作  
 * 选取 ${矩形区域} 内所有可破坏物 ${做动作}
 *
 * @remark
 * 组动作中可使用'选取的可破坏物'来获取对应的可破坏物. 每个可破坏物都会运行一次动作(包括死亡和隐藏的). 等待不能在组动作中运行.
 *
 * @TC_DESTRUCT
 */
declare function EnumDestructablesInRectAll(r: rect, actionFunc: () => void): void;
declare function EnumDestructablesInCircleBJFilter(): boolean;

/**
 * 可破坏物死亡  
 * ${可破坏物} 是死亡的
 *
 * @TC_DESTRUCT
 */
declare function IsDestructableDeadBJ(d: destructable): boolean;

/**
 * 可破坏物存活  
 * ${可破坏物} 是存活的
 *
 * @TC_DESTRUCT
 */
declare function IsDestructableAliveBJ(d: destructable): boolean;
declare function RandomDestructableInRectBJEnum(): void;

/**
 * 矩形区域内的随机可破坏物(指定条件)  
 * ${矩形区域} 内满足 ${条件} 的一个随机可破坏物
 *
 * @remark
 * 使用'匹配的可破坏物'来指代条件中用于比较的可破坏物.
 *
 * @TC_NOTHING
 */
declare function RandomDestructableInRectBJ(r: rect, filter: boolexpr | (() => boolean) | null): destructable;

/**
 * 矩形区域内的随机可破坏物  
 * ${矩形区域} 内随机选取一个可破坏物
 *
 * @TC_NOTHING
 */
declare function RandomDestructableInRectSimpleBJ(r: rect): destructable;

/**
 * 选取指定点范围内可破坏物做动作  
 * 选取 ${Radius} 范围以 ${指定点}为中心的区域内所有可破坏物 ${做动作}
 *
 * @remark
 * 组动作中可使用'选取的可破坏物'来获取对应的可破坏物. 每个可破坏物都会运行一次动作(包括死亡和隐藏的). 等待不能在组动作中运行.
 *
 * @TC_DESTRUCT
 */
declare function EnumDestructablesInCircleBJ(radius: number, loc: location, actionFunc: () => void): void;

/**
 * 设置生命值(百分比)  
 * 设置 ${可破坏物} 的生命值为 ${Percent}%
 *
 * @TC_DESTRUCT
 */
declare function SetDestructableLifePercentBJ(d: destructable, percent: number): void;

/**
 * 设置最大生命值  
 * 设置 ${可破坏物} 的最大生命值为 ${Value}
 *
 * @TC_DESTRUCT
 */
declare function SetDestructableMaxLifeBJ(d: destructable, max: number): void;

/**
 * 打开/关闭/破坏大门  
 * ${Open/Close/Destroy} ${大门}
 *
 * @TC_DESTRUCT
 */
declare function ModifyGateBJ(gateOperation: number, d: destructable): void;

/**
 * 升降机高度  
 * ${升降机} 的高度
 *
 * @remark
 * 可以使用'可破坏物 - 设置升降机高度'来设置升降机高度.
 *
 * @TC_DESTRUCT
 */
declare function GetElevatorHeight(d: destructable): number;

/**
 * 设置升降机高度  
 * 设置 ${升降机} 的高度为 ${Height}
 *
 * @TC_DESTRUCT
 */
declare function ChangeElevatorHeight(d: destructable, newHeight: number): void;
declare function NudgeUnitsInRectEnum(): void;
declare function NudgeItemsInRectEnum(): void;
declare function NudgeObjectsInRect(nudgeArea: rect): void;
declare function NearbyElevatorExistsEnum(): void;
declare function NearbyElevatorExists(x: number, y: number): boolean;
declare function FindElevatorWallBlockerEnum(): void;
declare function ChangeElevatorWallBlocker(x: number, y: number, facing: number, open: boolean): void;

/**
 * 打开/关闭升降机墙壁  
 * ${Open/Close} ${Walls} 对 ${升降机}
 *
 * @TC_DESTRUCT
 */
declare function ChangeElevatorWalls(open: boolean, walls: number, d: destructable): void;

/**
 * 启用/禁用 传送门  
 * ${Enable/Disable} ${传送门}
 *
 * @TC_NEUTRALBUILDING
 */
declare function WaygateActivateBJ(activate: boolean, waygate: unit): void;

/**
 * 传送门激活  
 * ${传送门} 处于激活状态
 *
 * @TC_NEUTRALBUILDING
 */
declare function WaygateIsActiveBJ(waygate: unit): boolean;

/**
 * 设置传送门目的点  
 * 设置 ${传送门} 的目的地为 ${Target}
 *
 * @TC_NEUTRALBUILDING
 */
declare function WaygateSetDestinationLocBJ(waygate: unit, loc: location): void;

/**
 * 传送门目的地  
 * ${传送门} 的目的地
 *
 * @remark
 * 会创建点.
 *
 * @TC_NEUTRALBUILDING
 */
declare function WaygateGetDestinationLocBJ(waygate: unit): location;

/**
 * 开启/关闭 小地图特殊标志  
 * ${On/Off} ${单位} 的小地图特殊标志
 *
 * @remark
 * 使用'中立建筑 - 设置小地图特殊标志'动作来设置显示的标志. 默认为中立建筑标志.
 *
 * @TC_NEUTRALBUILDING
 */
declare function UnitSetUsesAltIconBJ(flag: boolean, whichUnit: unit): void;

/**
 * 强制按键  
 * 命令 ${Player} 按下 ${Key} 键
 *
 * @TC_GAME
 */
declare function ForceUIKeyBJ(whichPlayer: player, key: string): void;

/**
 * 强制按Esc键  
 * 命令 ${Player} 按下Esc键
 *
 * @TC_GAME
 */
declare function ForceUICancelBJ(whichPlayer: player): void;
declare function ForGroupBJ(whichGroup: group, callback: () => void): void;

/**
 * 添加单位  
 * 添加 ${单位} 到 ${单位组}
 *
 * @remark
 * 并不影响单位本身.
 *
 * @TC_UNITGROUP
 */
declare function GroupAddUnitSimple(whichUnit: unit, whichGroup: group): void;

/**
 * 移除单位  
 * 把 ${单位} 从 ${单位组} 移除
 *
 * @remark
 * 并不影响单位本身.
 *
 * @TC_UNITGROUP
 */
declare function GroupRemoveUnitSimple(whichUnit: unit, whichGroup: group): void;
declare function GroupAddGroupEnum(): void;

/**
 * 添加单位组  
 * 添加 ${单位组} 内所有单位到 ${单位组}
 *
 * @remark
 * 并不影响单位本身.
 *
 * @TC_UNITGROUP
 */
declare function GroupAddGroup(sourceGroup: group, destGroup: group): void;
declare function GroupRemoveGroupEnum(): void;

/**
 * 移除单位组  
 * 把 ${单位组} 中的单位从 ${单位组} 移除
 *
 * @remark
 * 并不影响单位本身.
 *
 * @TC_UNITGROUP
 */
declare function GroupRemoveGroup(sourceGroup: group, destGroup: group): void;

/**
 * 添加玩家  
 * 添加 ${Player} 到 ${玩家组}
 *
 * @remark
 * 并不影响玩家本身.
 *
 * @TC_PLAYERGROUP
 */
declare function ForceAddPlayerSimple(whichPlayer: player, whichForce: force): void;

/**
 * 移除玩家  
 * 将 ${Player} 从 ${玩家组} 移除
 *
 * @remark
 * 并不影响玩家本身.
 *
 * @TC_PLAYERGROUP
 */
declare function ForceRemovePlayerSimple(whichPlayer: player, whichForce: force): void;
declare function GroupPickRandomUnitEnum(): void;

/**
 * 单位组中随机单位  
 * ${单位组} 中随机选取的一个单位
 *
 * @TC_NOTHING
 */
declare function GroupPickRandomUnit(whichGroup: group): unit;
declare function ForcePickRandomPlayerEnum(): void;

/**
 * 玩家组中随机玩家  
 * ${玩家组} 中随机抽取的一名玩家.
 *
 * @TC_NOTHING
 */
declare function ForcePickRandomPlayer(whichForce: force): player;
declare function EnumUnitsSelected(whichPlayer: player, enumFilter: boolexpr | (() => boolean) | null, enumAction: () => void): void;

/**
 * 矩形区域内的单位(指定条件)  
 * ${矩形区域} 内满足 ${条件} 的所有单位
 *
 * @remark
 * 使用'匹配单位'指代条件中用于比较的单位. 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsInRectMatching(r: rect, filter: boolexpr | (() => boolean) | null): group;

/**
 * 矩形区域内的单位  
 * ${矩形区域} 内的所有单位
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsInRectAll(r: rect): group;
declare function GetUnitsInRectOfPlayerFilter(): boolean;

/**
 * 矩形区域内的玩家单位  
 * ${矩形区域} 内属于 ${Player} 的所有单位
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsInRectOfPlayer(r: rect, whichPlayer: player): group;

/**
 * 圆范围内单位(指定条件)  
 * 半径为 ${Radius} 圆心为 ${指定点} 且满足 ${条件} 的所有单位
 *
 * @remark
 * 使用'匹配单位'指代条件中用于比较的单位. 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsInRangeOfLocMatching(radius: number, whichLocation: location, filter: boolexpr | (() => boolean) | null): group;

/**
 * 圆范围内单位  
 * 半径为 ${Radius} 圆心为 ${指定点} 的圆范围内所有单位
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsInRangeOfLocAll(radius: number, whichLocation: location): group;
declare function GetUnitsOfTypeIdAllFilter(): boolean;

/**
 * 所有指定类型单位  
 * 所有 ${单位类型}
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsOfTypeIdAll(unitid: number): group;

/**
 * 玩家单位(指定条件)  
 * 属于 ${Player} 并满足 ${条件} 的所有单位
 *
 * @remark
 * 使用'匹配单位'指代条件中用于比较的单位. 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsOfPlayerMatching(whichPlayer: player, filter: boolexpr | (() => boolean) | null): group;

/**
 * 玩家单位  
 * 属于 ${Player} 的所有单位
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsOfPlayerAll(whichPlayer: player): group;
declare function GetUnitsOfPlayerAndTypeIdFilter(): boolean;

/**
 * 玩家单位(指定单位类型)  
 * 属于 ${Player} 的所有 ${单位类型}
 *
 * @remark
 * 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsOfPlayerAndTypeId(whichPlayer: player, unitid: number): group;

/**
 * 玩家选择单位  
 * ${Player} 选择的所有单位
 *
 * @remark
 * 不能用于触发条件. 会创建单位组.
 *
 * @TC_NOTHING
 */
declare function GetUnitsSelectedAll(whichPlayer: player): group;

/**
 * 转换玩家为玩家组  
 * 转换 ${Player} 为玩家组
 *
 * @remark
 * 会创建玩家组.
 *
 * @TC_NOTHING
 */
declare function GetForceOfPlayer(whichPlayer: player): force;

/**
 * 所有玩家  
 * 所有玩家
 *
 * @remark
 * 包括未使用玩家和中立玩家.
 *
 * @TC_NOTHING
 */
declare function GetPlayersAll(): force;

/**
 * 所有指定控制者的玩家  
 * 所有 ${Control Type} 控制的玩家
 *
 * @remark
 * 会创建玩家组.
 *
 * @TC_NOTHING
 */
declare function GetPlayersByMapControl(whichControl: mapcontrol): force;

/**
 * 玩家的盟友  
 * 所有 ${Player} 的联盟玩家
 *
 * @remark
 * 需要双方互为联盟状态,包括自己,不包括中立玩家. 会创建玩家组.
 *
 * @TC_NOTHING
 */
declare function GetPlayersAllies(whichPlayer: player): force;

/**
 * 玩家的敌人  
 * 所有 ${Player} 的敌对玩家
 *
 * @remark
 * 对其敌对的所有玩家,不包括中立玩家. 会创建玩家组.
 *
 * @TC_NOTHING
 */
declare function GetPlayersEnemies(whichPlayer: player): force;

/**
 * 所有符合条件的玩家  
 * 所有符合 ${条件} 的玩家
 *
 * @remark
 * 使用'匹配玩家'指代条件中用于比较的玩家,包括未使用玩家和中立玩家. 会创建玩家组.
 *
 * @TC_NOTHING
 */
declare function GetPlayersMatching(filter: boolexpr | (() => boolean) | null): force;
declare function CountUnitsInGroupEnum(): void;

/**
 * 单位组中单位数量  
 * ${单位组} 中的单位数量
 *
 * @TC_UNIT
 */
declare function CountUnitsInGroup(g: group): number;
declare function CountPlayersInForceEnum(): void;

/**
 * 玩家组中玩家数量  
 * ${玩家组} 中的玩家数量
 *
 * @TC_PLAYER
 */
declare function CountPlayersInForceBJ(f: force): number;
declare function GetRandomSubGroupEnum(): void;

/**
 * 单位组中随机单位  
 * 随机获取 ${Count} 个单位从 ${单位组}
 *
 * @remark
 * 会创建单位组.该函数不能使用设置 bj_wantDestroyGroup
 *
 * @TC_NOTHING
 */
declare function GetRandomSubGroup(count: number, sourceGroup: group): group;
declare function LivingPlayerUnitsOfTypeIdFilter(): boolean;

/**
 * 玩家拥有单位数量  
 * ${单位类型} 的数量对 ${Player}
 *
 * @TC_UNIT
 */
declare function CountLivingPlayerUnitsOfTypeId(unitId: number, whichPlayer: player): number;

/**
 * 重置单位动画  
 * 重置 ${单位} 的动作,恢复到普通状态
 *
 * @remark
 * 无论该单位在什么动作,都将把单位的动作恢复到普通状态(也就是'stand'动作的状态).
 *
 * @TC_ANIMATION
 */
declare function ResetUnitAnimation(whichUnit: unit): void;

/**
 * 改变单位动画播放速度(按百分比)  
 * 改变 ${单位} 的动画播放速度为正常速度的 ${Percent}%
 *
 * @remark
 * 设置100%动画播放速度来恢复正常状态.
 *
 * @TC_ANIMATION
 */
declare function SetUnitTimeScalePercent(whichUnit: unit, percentScale: number): void;

/**
 * 改变单位尺寸(按比例)  
 * 设置 ${Unit} 的缩放尺寸为 (${X}%, ${Y}%, ${Z}%)
 *
 * @remark
 * 缩放尺寸使用(长,宽,高)格式.
 *
 * @TC_ANIMATION
 */
declare function SetUnitScalePercent(whichUnit: unit, percentScaleX: number, percentScaleY: number, percentScaleZ: number): void;

/**
 * 改变单位颜色(RGB:0-100%)  
 * 改变 ${单位}  的颜色比例: (${Red}%, ${Green}%, ${Blue}%),透明度: ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 大多数单位使用100%的颜色值和0%透明度. 100%透明度是完全透明的.
 *
 * @TC_ANIMATION
 */
declare function SetUnitVertexColorBJ(whichUnit: unit, red: number, green: number, blue: number, transparency: number): void;

/**
 * 闪动指示器(对单位)  
 * 对 ${单位} 闪动指示器,使用颜色(${Red}%, ${Green}%, ${Blue}%) 透明度 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_CINEMATIC
 */
declare function UnitAddIndicatorBJ(whichUnit: unit, red: number, green: number, blue: number, transparency: number): void;

/**
 * 闪动指示器(对可破坏物)  
 * 对 ${可破坏物} 闪动指示器,使用颜色(${Red}%, ${Green}%, ${Blue}%) 透明度 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_CINEMATIC
 */
declare function DestructableAddIndicatorBJ(whichDestructable: destructable, red: number, green: number, blue: number, transparency: number): void;

/**
 * 闪动指示器(对物品)  
 * 对 ${物品} 闪动指示器,使用颜色(${Red}%, ${Green}%, ${Blue}%) 透明度 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_CINEMATIC
 */
declare function ItemAddIndicatorBJ(whichItem: item, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置单位面向点  
 * 设置 ${单位} 面向 ${点} ,使用时间 ${Time} 秒
 *
 * @TC_UNIT
 */
declare function SetUnitFacingToFaceLocTimed(whichUnit: unit, target: location, duration: number): void;

/**
 * 设置单位面向单位  
 * 设置 ${单位} 面向 ${目标单位} ,使用时间 ${Time} 秒
 *
 * @remark
 * 只是面向当前单位所在点而已. 并不会因为单位位置改变而改变目标位置.
 *
 * @TC_UNIT
 */
declare function SetUnitFacingToFaceUnitTimed(whichUnit: unit, target: unit, duration: number): void;

/**
 * 单位动画加入队列  
 * 把 ${单位} 的 ${Animation Name} 动作添加到动作队列
 *
 * @remark
 * 单位按队列中运作的先后顺序播放动作.
 *
 * @TC_ANIMATION
 */
declare function QueueUnitAnimationBJ(whichUnit: unit, whichAnimation: string): void;

/**
 * 播放可破坏物动画  
 * 播放 ${可破坏物} 的 ${Animation Name} 动作
 *
 * @TC_ANIMATION
 */
declare function SetDestructableAnimationBJ(d: destructable, whichAnimation: string): void;

/**
 * 将可破坏物动画加入队列  
 * 将 ${可破坏物} 的 ${Animation Name} 动作加入队列
 *
 * @TC_ANIMATION
 */
declare function QueueDestructableAnimationBJ(d: destructable, whichAnimation: string): void;

/**
 * 改变可破坏物动画播放速度  
 * 改变 ${可破坏物} 的动画播放速度为正常的 ${Percent}%
 *
 * @remark
 * 设置100%动画播放速度来恢复正常状态.
 *
 * @TC_ANIMATION
 */
declare function SetDestAnimationSpeedPercent(d: destructable, percentScale: number): void;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${Dialog} 对 ${Player}
 *
 * @remark
 * 对话框不能应用于地图初始化事件.
 *
 * @TC_DIALOG
 */
declare function DialogDisplayBJ(flag: boolean, whichDialog: dialog, whichPlayer: player): void;

/**
 * 改变标题  
 * 改变 ${Dialog} 的标题为 ${Title}
 *
 * @TC_DIALOG
 */
declare function DialogSetMessageBJ(whichDialog: dialog, message: string): void;

/**
 * 添加对话按钮  
 * 为 ${Dialog} 添加一个对话按钮,按钮标签为 ${Text}
 *
 * @remark
 * 使用'最后创建的对话按钮'来获得创建的对话按钮.
 *
 * @TC_DIALOG
 */
declare function DialogAddButtonBJ(whichDialog: dialog, buttonText: string): button;

/**
 * 添加对话框按钮(有快捷键) [R]  
 * 为 ${对话框} 添加一个按钮,按钮标题为: ${文字},快捷键为: ${HotKey}
 *
 * @remark
 * 使用'最后创建的对话按钮'来获得创建的对话按钮.
 *
 * @TC_DIALOG
 */
declare function DialogAddButtonWithHotkeyBJ(whichDialog: dialog, buttonText: string, hotkey: number): button;

/**
 * 清空  
 * 清空 ${Dialog}
 *
 * @remark
 * 清除对话框的标题和按钮.
 *
 * @TC_DIALOG
 */
declare function DialogClearBJ(whichDialog: dialog): void;

/**
 * 最后创建的对话框按钮  
 * 最后创建的对话框按钮
 *
 * @remark
 * 最后一个由'对话框 - 创建对话框按钮'动作创建的对话框按钮.
 *
 * @TC_LAST
 */
declare function GetLastCreatedButtonBJ(): button;

/**
 * 点击的对话框按钮  
 * 点击的对话框按钮
 *
 * @remark
 * 响应'对话框 - 点击对话框/按钮'事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetClickedButtonBJ(): button;

/**
 * 点击的对话框  
 * 点击的对话框
 *
 * @remark
 * 响应'对话框 - 点击对话框/按钮'事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetClickedDialogBJ(): dialog;

/**
 * 设置联盟状态(指定项目)  
 * 命令 ${Player} 设置 ${Alliance Type} ${On/Off} 对 ${Player}
 *
 * @TC_PLAYER
 */
declare function SetPlayerAllianceBJ(sourcePlayer: player, whichAllianceSetting: alliancetype, value: boolean, otherPlayer: player): void;
declare function SetPlayerAllianceStateAllyBJ(sourcePlayer: player, otherPlayer: player, flag: boolean): void;
declare function SetPlayerAllianceStateVisionBJ(sourcePlayer: player, otherPlayer: player, flag: boolean): void;
declare function SetPlayerAllianceStateControlBJ(sourcePlayer: player, otherPlayer: player, flag: boolean): void;
declare function SetPlayerAllianceStateFullControlBJ(sourcePlayer: player, otherPlayer: player, flag: boolean): void;

/**
 * 设置联盟状态  
 * 命令 ${Player} 设置对 ${Player} 的联盟状态为 ${Alliance Setting}
 *
 * @TC_PLAYER
 */
declare function SetPlayerAllianceStateBJ(sourcePlayer: player, otherPlayer: player, allianceState: number): void;

/**
 * 设置联盟  
 * 命令 ${Player} 设置对 ${Player} 的联盟状态为 ${Alliance Setting}
 *
 * @TC_PLAYERGROUP
 */
declare function SetForceAllianceStateBJ(sourceForce: force, targetForce: force, allianceState: number): void;
declare function PlayersAreCoAllied(playerA: player, playerB: player): boolean;
declare function ShareEverythingWithTeamAI(whichPlayer: player): void;

/**
 * 共享视野和完全控制权  
 * 设置 ${Player} 对盟友共享视野和完全控制权
 *
 * @remark
 * 当玩家互相为盟友时才有效. 同时玩家也会获得其盟友的单位控制权.
 *
 * @TC_GAME
 */
declare function ShareEverythingWithTeam(whichPlayer: player): void;
declare function ConfigureNeutralVictim(): void;
declare function MakeUnitsPassiveForPlayerEnum(): void;

/**
 * 设置玩家单位为中立受害单位  
 * 改变 ${Player} 所有单位为中立受害单位
 *
 * @remark
 * 默认状态中立受害受所有玩家欺凌而不抵抗.
 *
 * @TC_GAME
 */
declare function MakeUnitsPassiveForPlayer(whichPlayer: player): void;
declare function MakeUnitsPassiveForTeam(whichPlayer: player): void;
declare function AllowVictoryDefeat(gameResult: playergameresult): boolean;
declare function EndGameBJ(): void;
declare function MeleeVictoryDialogBJ(whichPlayer: player, leftGame: boolean): void;
declare function MeleeDefeatDialogBJ(whichPlayer: player, leftGame: boolean): void;
declare function GameOverDialogBJ(whichPlayer: player, leftGame: boolean): void;
declare function RemovePlayerPreserveUnitsBJ(whichPlayer: player, gameResult: playergameresult, leftGame: boolean): void;
declare function CustomVictoryOkBJ(): void;
declare function CustomVictoryQuitBJ(): void;
declare function CustomVictoryDialogBJ(whichPlayer: player): void;
declare function CustomVictorySkipBJ(whichPlayer: player): void;

/**
 * 游戏胜利  
 * 设置 ${Player} 胜利(${Show/Skip} 胜利对话框, ${Show/Skip} 计分屏)
 *
 * @TC_GAME
 */
declare function CustomVictoryBJ(whichPlayer: player, showDialog: boolean, showScores: boolean): void;
declare function CustomDefeatRestartBJ(): void;
declare function CustomDefeatReduceDifficultyBJ(): void;
declare function CustomDefeatLoadBJ(): void;
declare function CustomDefeatQuitBJ(): void;
declare function CustomDefeatDialogBJ(whichPlayer: player, message: string): void;

/**
 * 游戏失败  
 * 设置 ${Player} 失败并显示失败信息: ${文字}
 *
 * @TC_GAME
 */
declare function CustomDefeatBJ(whichPlayer: player, message: string): void;

/**
 * 设置下一关卡  
 * 设置下一关卡为 ${Level}
 *
 * @remark
 * 设置游戏结束后的下一关卡.
 *
 * @TC_GAME
 */
declare function SetNextLevelBJ(nextLevel: string): void;

/**
 * 显示/隐藏计分屏显示  
 * ${Show/Hide} ${Player} 在计分屏的显示.
 *
 * @TC_PLAYER
 */
declare function SetPlayerOnScoreScreenBJ(flag: boolean, whichPlayer: player): void;

/**
 * 创建任务  
 * 创建一个 ${Quest Type} 任务,标题: ${文字} 任务说明: ${文字} 任务图标: ${Icon Path}
 *
 * @TC_QUEST
 */
declare function CreateQuestBJ(questType: number, title: string, description: string, iconPath: string): quest;

/**
 * 删除任务  
 * 删除 ${Quest}
 *
 * @remark
 * 被删除的任务将不再显示在任务列表.
 *
 * @TC_QUEST
 */
declare function DestroyQuestBJ(whichQuest: quest): void;

/**
 * 启用/禁用任务  
 * ${Enable/Disable} ${Quest}
 *
 * @remark
 * 被禁用的任务将不会显示在任务列表.
 *
 * @TC_QUEST
 */
declare function QuestSetEnabledBJ(enabled: boolean, whichQuest: quest): void;

/**
 * 设置任务标题  
 * 设置 ${Quest} 的标题为 ${文字}
 *
 * @TC_QUEST
 */
declare function QuestSetTitleBJ(whichQuest: quest, title: string): void;

/**
 * 设置任务说明  
 * 设置 ${Quest} 的任务说明为: ${文字}
 *
 * @TC_QUEST
 */
declare function QuestSetDescriptionBJ(whichQuest: quest, description: string): void;

/**
 * 设置任务完成  
 * 设置 ${Quest} ${Completed/Incomplete}
 *
 * @TC_QUEST
 */
declare function QuestSetCompletedBJ(whichQuest: quest, completed: boolean): void;

/**
 * 设置任务失败  
 * 设置 ${Quest} ${Failed/Not Failed}
 *
 * @TC_QUEST
 */
declare function QuestSetFailedBJ(whichQuest: quest, failed: boolean): void;

/**
 * 设置任务被发现  
 * 设置 ${Quest} ${Discovered/Undiscovered}
 *
 * @TC_QUEST
 */
declare function QuestSetDiscoveredBJ(whichQuest: quest, discovered: boolean): void;

/**
 * 最后创建的任务  
 * 最后创建的任务
 *
 * @remark
 * 最后一个由'任务 - 创建任务'动作创建的任务.
 *
 * @TC_LAST
 */
declare function GetLastCreatedQuestBJ(): quest;

/**
 * 创建任务项目  
 * 为 ${Quest} 创建一个任务项目: ${文字}
 *
 * @TC_QUEST
 */
declare function CreateQuestItemBJ(whichQuest: quest, description: string): questitem;

/**
 * 改变任务项目说明  
 * 改变 ${Quest Requirement} 的说明为: ${文字}
 *
 * @TC_QUEST
 */
declare function QuestItemSetDescriptionBJ(whichQuestItem: questitem, description: string): void;

/**
 * 设置任务项目完成  
 * 设置 ${Quest Requirement} ${Completed/Incomplete}
 *
 * @TC_QUEST
 */
declare function QuestItemSetCompletedBJ(whichQuestItem: questitem, completed: boolean): void;

/**
 * 最后创建的任务项目  
 * 最后创建的任务项目
 *
 * @remark
 * 最后一个由'任务 - 创建任务项目'动作创建的任务项目.
 *
 * @TC_LAST
 */
declare function GetLastCreatedQuestItemBJ(): questitem;

/**
 * 创建失败条件  
 * 创建失败条件: ${文字}
 *
 * @remark
 * 失败条件会在每个任务中显示.
 *
 * @TC_QUEST
 */
declare function CreateDefeatConditionBJ(description: string): defeatcondition;

/**
 * 删除失败条件  
 * 删除 ${Defeat Condition}
 *
 * @remark
 * 被删除的失败条件会从每个任务中移除.
 *
 * @TC_QUEST
 */
declare function DestroyDefeatConditionBJ(whichCondition: defeatcondition): void;

/**
 * 改变失败条件说明  
 * 改变 ${Defeat Condition} 的说明为: ${文字}
 *
 * @TC_QUEST
 */
declare function DefeatConditionSetDescriptionBJ(whichCondition: defeatcondition, description: string): void;

/**
 * 最后创建的失败条件  
 * 最后创建的失败条件
 *
 * @remark
 * 最后一个由'任务 - 创建失败条件'动作创建的失败条件.
 *
 * @TC_LAST
 */
declare function GetLastCreatedDefeatConditionBJ(): defeatcondition;

/**
 * 闪动任务按钮  
 * 闪动任务按钮
 *
 * @TC_QUEST
 */
declare function FlashQuestDialogButtonBJ(): void;

/**
 * 发送任务信息  
 * 对 ${玩家组} 发送 ${Quest Message Type} 信息: ${文字}
 *
 * @TC_QUEST
 */
declare function QuestMessageBJ(f: force, messageType: number, message: string): void;

/**
 * 运行计时器  
 * 运行 ${计时器}，模式: ${模式}，周期: ${时间} 秒
 *
 * @TC_TIMER
 */
declare function StartTimerBJ(t: timer, periodic: boolean, timeout: number): timer;
declare function CreateTimerBJ(periodic: boolean, timeout: number): timer;
declare function DestroyTimerBJ(whichTimer: timer): void;

/**
 * 暂停/恢复 计时器  
 * ${Pause/Resume} ${Timer}
 *
 * @TC_TIMER
 */
declare function PauseTimerBJ(pause: boolean, whichTimer: timer): void;

/**
 * 最后启用的计时器  
 * 最后启用的计时器
 *
 * @remark
 * 最后一个由'计时器 - 启用计时器'动作启用的计时器.
 *
 * @TC_LAST
 */
declare function GetLastCreatedTimerBJ(): timer;

/**
 * 创建计时器窗口  
 * 为 ${计时器} 创建计时器窗口,标题: ${文字}
 *
 * @remark
 * 计时器窗口不能在地图初始化时显示.
 *
 * @TC_TIMER
 */
declare function CreateTimerDialogBJ(t: timer, title: string): timerdialog;

/**
 * 删除计时器窗口  
 * 删除 ${计时器窗口}
 *
 * @TC_TIMER
 */
declare function DestroyTimerDialogBJ(td: timerdialog): void;

/**
 * 改变计时器窗口标题  
 * 改变 ${Timer Window} 的标题为 ${Title}
 *
 * @TC_TIMER
 */
declare function TimerDialogSetTitleBJ(td: timerdialog, title: string): void;

/**
 * 改变计时器窗口标题颜色  
 * 改变 ${Timer Window} 的标题颜色为 (${红}%, ${绿}%, ${蓝}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_TIMER
 */
declare function TimerDialogSetTitleColorBJ(td: timerdialog, red: number, green: number, blue: number, transparency: number): void;

/**
 * 改变计时器窗口计时颜色  
 * 改变 ${Timer Window} 的计时颜色为 (${红}%, ${绿}%, ${蓝}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_TIMER
 */
declare function TimerDialogSetTimeColorBJ(td: timerdialog, red: number, green: number, blue: number, transparency: number): void;
declare function TimerDialogSetSpeedBJ(td: timerdialog, speedMultFactor: number): void;

/**
 * 显示/隐藏 计时器窗口(指定玩家)  
 * ${Show/Hide} ${计时器窗口} 应用于 ${Player}
 *
 * @remark
 * 计时器窗口不能在地图初始化时显示.
 *
 * @TC_TIMER
 */
declare function TimerDialogDisplayForPlayerBJ(show: boolean, td: timerdialog, whichPlayer: player): void;

/**
 * 显示/隐藏 计时器窗口(所有玩家)  
 * ${Show/Hide} ${计时器窗口}
 *
 * @remark
 * 计时器窗口不能在地图初始化时显示.
 *
 * @TC_TIMER
 */
declare function TimerDialogDisplayBJ(show: boolean, td: timerdialog): void;

/**
 * 最后创建的计时器窗口  
 * 最后创建的计时器窗口
 *
 * @remark
 * 最后一个由'计时器 - 创建计时器窗口'动作创建的计时器窗口.
 *
 * @TC_LAST
 */
declare function GetLastCreatedTimerDialogBJ(): timerdialog;
declare function LeaderboardResizeBJ(lb: leaderboard): void;

/**
 * 改变玩家分数  
 * 设置 ${Player} 在 ${Leaderboard} 中的分数为: ${Value}
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetPlayerItemValueBJ(whichPlayer: player, lb: leaderboard, val: number): void;

/**
 * 改变玩家名字  
 * 设置 ${Player} 在 ${Leaderboard} 中的名字为 ${文字}
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetPlayerItemLabelBJ(whichPlayer: player, lb: leaderboard, val: string): void;

/**
 * 设置玩家显示样式  
 * 设置 ${Player} 在 ${Leaderboard} 中的显示样式: ${Show/Hide} 名字, ${Show/Hide} 分数, ${Show/Hide} 图标
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetPlayerItemStyleBJ(whichPlayer: player, lb: leaderboard, showLabel: boolean, showValue: boolean, showIcon: boolean): void;

/**
 * 设置玩家名字颜色  
 * 设置 ${Player} 在 ${Leaderboard} 中的名字颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetPlayerItemLabelColorBJ(whichPlayer: player, lb: leaderboard, red: number, green: number, blue: number, transparency: number): void;

/**
 * 改变玩家分数颜色  
 * 设置 ${Player} 在 ${Leaderboard} 中的分数颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetPlayerItemValueColorBJ(whichPlayer: player, lb: leaderboard, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置文字颜色  
 * 设置 ${Leaderboard} 的文字颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetLabelColorBJ(lb: leaderboard, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置数值颜色  
 * 设置 ${Leaderboard} 的数值颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetValueColorBJ(lb: leaderboard, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置标题  
 * 设置 ${Leaderboard} 的标题为 ${文字}
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetLabelBJ(lb: leaderboard, label: string): void;

/**
 * 设置显示样式  
 * 设置 ${Leaderboard} 的显示样式: ${Show/Hide} 标题, ${Show/Hide} 文字, ${Show/Hide} 分数, ${Show/Hide} 图标
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSetStyleBJ(lb: leaderboard, showLabel: boolean, showNames: boolean, showValues: boolean, showIcons: boolean): void;
declare function LeaderboardGetItemCountBJ(lb: leaderboard): number;

/**
 * 玩家在排行榜  
 * ${Leaderboard} 中包含 ${Player}
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardHasPlayerItemBJ(lb: leaderboard, whichPlayer: player): boolean;
declare function ForceSetLeaderboardBJ(lb: leaderboard, toForce: force): void;

/**
 * 创建  
 * 对 ${玩家组} 创建排行榜,使用标题: ${文字}
 *
 * @remark
 * 排行榜不能在地图初始化时显示. 标题为空则不显示标题栏.
 *
 * @TC_LEADERBOARD
 */
declare function CreateLeaderboardBJ(toForce: force, label: string): leaderboard;

/**
 * 删除  
 * 删除 ${排行榜}
 *
 * @TC_LEADERBOARD
 */
declare function DestroyLeaderboardBJ(lb: leaderboard): void;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${排行榜}
 *
 * @remark
 * 排行榜不能在地图初始化时显示.
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardDisplayBJ(show: boolean, lb: leaderboard): void;

/**
 * 添加玩家  
 * 添加 ${Player} 到 ${Leaderboard} ,使用名字: ${文字} 设置分数: ${Value}
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardAddItemBJ(whichPlayer: player, lb: leaderboard, label: string, value: number): void;

/**
 * 移除玩家  
 * 把 ${Player} 从 ${Leaderboard} 移除
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardRemovePlayerItemBJ(whichPlayer: player, lb: leaderboard): void;

/**
 * 排序  
 * 将 ${排行榜} 按 ${Field} 使用 ${Ascending/Descending} 排列
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardSortItemsBJ(lb: leaderboard, sortType: number, ascending: boolean): void;
declare function LeaderboardSortItemsByPlayerBJ(lb: leaderboard, ascending: boolean): void;
declare function LeaderboardSortItemsByLabelBJ(lb: leaderboard, ascending: boolean): void;

/**
 * 排行榜位置  
 * ${Player} 在 ${Leaderboard} 的排名
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardGetPlayerIndexBJ(whichPlayer: player, lb: leaderboard): number;

/**
 * 玩家所在排行榜位置  
 * 第 ${Position} 位玩家在 ${Leaderboard} 中
 *
 * @TC_LEADERBOARD
 */
declare function LeaderboardGetIndexedPlayerBJ(position: number, lb: leaderboard): player;

/**
 * 玩家使用的排行榜  
 * ${Player} 使用的排行榜
 *
 * @remark
 * 每个玩家只能使用1个排行榜.
 *
 * @TC_NOTHING
 */
declare function PlayerGetLeaderboardBJ(whichPlayer: player): leaderboard;

/**
 * 最后创建的排行榜  
 * 最后创建的排行榜
 *
 * @remark
 * 最后一个由'排行榜 - 创建排行榜'动作创建的排行榜.
 *
 * @TC_LAST
 */
declare function GetLastCreatedLeaderboard(): leaderboard;

/**
 * 创建  
 * 创建一个列数为 ${Columns} 行数为 ${Rows} 标题为 ${文字} 的多面板
 *
 * @remark
 * 多面板不能在地图初始化时显示.
 *
 * @TC_MULTIBOARD
 */
declare function CreateMultiboardBJ(cols: number, rows: number, title: string): multiboard;

/**
 * 删除  
 * 删除 ${Multiboard}
 *
 * @TC_MULTIBOARD
 */
declare function DestroyMultiboardBJ(mb: multiboard): void;

/**
 * 最后创建的多面板  
 * 最后创建的多面板
 *
 * @remark
 * 最后一个由'多面板 - 创建多面板'动作创建的多面板.
 *
 * @TC_LAST
 */
declare function GetLastCreatedMultiboard(): multiboard;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${Multiboard}
 *
 * @remark
 * 多面板不能在地图初始化时显示.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardDisplayBJ(show: boolean, mb: multiboard): void;

/**
 * 最大/最小化  
 * ${Minimize/Maximize} ${Multiboard}
 *
 * @remark
 * 最小化的多面板只显示标题.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardMinimizeBJ(minimize: boolean, mb: multiboard): void;

/**
 * 设置标题颜色  
 * 设置 ${Multiboard} 的标题颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetTitleTextColorBJ(mb: multiboard, red: number, green: number, blue: number, transparency: number): void;

/**
 * 显示/隐藏多面板模式  
 * ${Show/Hide} 多面板模式
 *
 * @remark
 * 隐藏多面板模式将无法显示多面板.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardAllowDisplayBJ(flag: boolean): void;

/**
 * 设置项目显示风格  
 * 设置 ${Multiboard} 第 ${Column} 列,第 ${Row} 行项目的显示风格: ${Show/Hide} 文字 ${Show/Hide} 图标
 *
 * @remark
 * 可以设置行/列数为0来指代所有的行/列. 
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetItemStyleBJ(mb: multiboard, col: number, row: number, showValue: boolean, showIcon: boolean): void;

/**
 * 设置项目文本  
 * 设置 ${Multiboard} 第 ${Column} 列,第 ${Row} 行的项目文本为 ${文字}
 *
 * @remark
 * 可以设置行/列数为0来指代所有的行/列.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetItemValueBJ(mb: multiboard, col: number, row: number, val: string): void;

/**
 * 设置项目颜色  
 * 设置 ${Multiboard} 第 ${Column} 列,第 ${Row} 行的项目颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 可以设置行/列数为0来指代所有的行/列. 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetItemColorBJ(mb: multiboard, col: number, row: number, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置项目宽度  
 * 设置 ${Multiboard} 第 ${Column} 列,第 ${Row} 行的项目宽度为屏幕的 ${Width}%
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetItemWidthBJ(mb: multiboard, col: number, row: number, width: number): void;

/**
 * 设置项目图标  
 * 设置 ${Multiboard} 第 ${Column} 列,第 ${Row} 行的项目图标为 ${Icon File}
 *
 * @TC_MULTIBOARD
 */
declare function MultiboardSetItemIconBJ(mb: multiboard, col: number, row: number, iconFileName: string): void;
declare function TextTagSize2Height(size: number): number;
declare function TextTagSpeed2Velocity(speed: number): number;

/**
 * 改变颜色  
 * 改变 ${Floating Text} 的颜色为(${Red}%, ${Green}%, ${Blue}%) 透明度为 ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagColorBJ(tt: texttag, red: number, green: number, blue: number, transparency: number): void;

/**
 * 设置速率  
 * 设置 ${Floating Text} 的移动速率为 ${Speed} ,方向为 ${Angle} 度
 *
 * @remark
 * 对移动后的漂浮文字设置速率,该漂浮文字会先回到原点再向设定的角度移动. 方向采用角度制,0度为正东方向,90度为正北方向.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagVelocityBJ(tt: texttag, speed: number, angle: number): void;

/**
 * 改变文字内容  
 * 改变 ${Floating Text} 的内容为 ${文字} ,字体大小: ${Size}
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagTextBJ(tt: texttag, s: string, size: number): void;

/**
 * 改变位置(点)  
 * 改变 ${Floating Text} 的位置为 ${指定点} ,Z轴高度为 ${Z}
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagPosBJ(tt: texttag, loc: location, zOffset: number): void;

/**
 * 改变位置(单位)  
 * 改变 ${Floating Text} 的位置到 ${单位} 头顶Z轴偏移 ${Z} 处
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagPosUnitBJ(tt: texttag, whichUnit: unit, zOffset: number): void;

/**
 * 暂停/恢复  
 * 设置 ${Floating Text} : ${Enable/Disable} 暂停状态
 *
 * @remark
 * 暂停状态暂停漂浮文字的移动和生命计时.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagSuspendedBJ(tt: texttag, flag: boolean): void;

/**
 * 设置永久显示  
 * 设置 ${Floating Text} : ${Enable/Disable} 永久显示.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagPermanentBJ(tt: texttag, flag: boolean): void;

/**
 * 设置已存在时间  
 * 设置 ${Floating Text} 的已存在时间为 ${Time} 秒
 *
 * @remark
 * 该动作并不影响永久性漂浮文字. 
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagAgeBJ(tt: texttag, age: number): void;

/**
 * 设置显示时间  
 * 设置 ${Floating Text} 的显示时间为 ${Time} 秒
 *
 * @remark
 * 该动作并不影响永久性漂浮文字. 当显示时间到期时,系统会自动清除该漂浮文字.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagLifespanBJ(tt: texttag, lifespan: number): void;

/**
 * 设置消逝时间点  
 * 设置 ${Floating Text} 的消逝时间点为 ${Time} 秒
 *
 * @remark
 * 该动作并不影响永久性漂浮文字. 当漂浮文字存在时间到达该值时会开始淡化消逝.
 *
 * @TC_TEXTTAG
 */
declare function SetTextTagFadepointBJ(tt: texttag, fadepoint: number): void;

/**
 * 创建漂浮文字(指定地点)  
 * 创建漂浮文字: ${文字} 在 ${指定点},Z轴高度: ${Z} ,字体大小: ${Size} ,颜色值:(${Red}%, ${Green}%, ${Blue}%) ,透明度: ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_TEXTTAG
 */
declare function CreateTextTagLocBJ(s: string, loc: location, zOffset: number, size: number, red: number, green: number, blue: number, transparency: number): texttag;

/**
 * 创建漂浮文字(指定单位)  
 * 创建漂浮文字: ${文字} 在 ${单位}的头顶, Z轴偏移 ${Z},字体大小: ${Size} ,颜色值:(${Red}%, ${Green}%, ${Blue}%) ,透明度: ${Transparency}%
 *
 * @remark
 * 该方式创建的漂浮文字并不会跟随单位一起移动.  颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_TEXTTAG
 */
declare function CreateTextTagUnitBJ(s: string, whichUnit: unit, zOffset: number, size: number, red: number, green: number, blue: number, transparency: number): texttag;

/**
 * 删除  
 * 删除 ${Floating Text}
 *
 * @remark
 * 游戏最多允许存在100个漂浮文字,所以请及时删除不再使用的漂浮文字.
 *
 * @TC_TEXTTAG
 */
declare function DestroyTextTagBJ(tt: texttag): void;

/**
 * 显示/隐藏  
 * ${Show/Hide} ${Floating Text} 对 ${玩家组}
 *
 * @TC_TEXTTAG
 */
declare function ShowTextTagForceBJ(show: boolean, tt: texttag, whichForce: force): void;

/**
 * 最后创建的漂浮文字  
 * 最后创建的漂浮文字
 *
 * @remark
 * 最后一个由'漂浮文字 - 创建漂浮文字'动作创建的漂浮文字.
 *
 * @TC_LAST
 */
declare function GetLastCreatedTextTag(): texttag;

/**
 * 暂停游戏  
 * 暂停游戏
 *
 * @TC_GAME
 */
declare function PauseGameOn(): void;

/**
 * 恢复游戏  
 * 恢复游戏
 *
 * @TC_GAME
 */
declare function PauseGameOff(): void;

/**
 * 启用玩家控制权(指定玩家组)  
 * 启用 ${玩家组} 的控制权
 *
 * @TC_CINEMATIC
 */
declare function SetUserControlForceOn(whichForce: force): void;

/**
 * 禁用玩家控制权(指定玩家组)  
 * 禁用 ${玩家组} 的控制权
 *
 * @TC_CINEMATIC
 */
declare function SetUserControlForceOff(whichForce: force): void;

/**
 * 信箱模式开启关闭(指定玩家组)  
 * 对 ${玩家组} 关闭信箱模式,转换时间为 ${Duration} 秒
 *
 * @remark
 * 关闭信箱模式,返回游戏界面.
 *
 * @TC_CINEMATIC
 */
declare function ShowInterfaceForceOn(whichForce: force, fadeDuration: number): void;

/**
 * 信箱模式开启(指定玩家组)  
 * 对 ${玩家组} 开启信箱模式,转换时间为 ${Duration} 秒
 *
 * @remark
 * 使用电影镜头模式,隐藏游戏界面.
 *
 * @TC_CINEMATIC
 */
declare function ShowInterfaceForceOff(whichForce: force, fadeDuration: number): void;
declare function PingMinimapForForce(whichForce: force, x: number, y: number, duration: number): void;

/**
 * 小地图信号(指定玩家组)  
 * 对 ${玩家组} 发送小地图信号到 ${指定点} ,持续时间: ${Duration} 秒
 *
 * @TC_CINEMATIC
 */
declare function PingMinimapLocForForce(whichForce: force, loc: location, duration: number): void;
declare function PingMinimapForPlayer(whichPlayer: player, x: number, y: number, duration: number): void;
declare function PingMinimapLocForPlayer(whichPlayer: player, loc: location, duration: number): void;
declare function PingMinimapForForceEx(whichForce: force, x: number, y: number, duration: number, style: number, red: number, green: number, blue: number): void;

/**
 * 小地图信号(指定颜色)(指定玩家组)  
 * 对 ${玩家组} 发送小地图信号到 ${指定点} ,持续时间: ${Duration} 秒,信号类型: ${Style} 信号颜色:(${Red}%, ${Green}%, ${Blue}%)
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 警告信号总是红色不可变.
 *
 * @TC_CINEMATIC
 */
declare function PingMinimapLocForForceEx(whichForce: force, loc: location, duration: number, style: number, red: number, green: number, blue: number): void;

/**
 * 允许/禁止 边界染色(指定玩家组)  
 * ${Enable/Disable} 边界染色,应用于 ${玩家组}
 *
 * @remark
 * 禁用边界染色时边界为普通地形,不显示为黑色,但仍是不可通行的.
 *
 * @TC_CINEMATIC
 */
declare function EnableWorldFogBoundaryBJ(enable: boolean, f: force): void;

/**
 * 允许/禁止闭塞(指定玩家组)  
 * ${Enable/Disable} 闭塞对 ${玩家组}
 *
 * @TC_CINEMATIC
 */
declare function EnableOcclusionBJ(enable: boolean, f: force): void;
declare function CancelCineSceneBJ(): void;
declare function TryInitCinematicBehaviorBJ(): void;
declare function SetCinematicSceneBJ(soundHandle: sound, portraitUnitId: number, color: playercolor, speakerTitle: string, text: string, sceneDuration: number, voiceoverDuration: number): void;
declare function GetTransmissionDuration(soundHandle: sound, timeType: number, timeVal: number): number;
declare function WaitTransmissionDuration(soundHandle: sound, timeType: number, timeVal: number): void;
declare function DoTransmissionBasicsXYBJ(unitId: number, color: playercolor, x: number, y: number, soundHandle: sound, unitName: string, message: string, duration: number): void;

/**
 * 播送单位消息(指定单位)  
 * 对 ${玩家组} 播送信息,发言单位: ${单位} 显示名字: ${文字} ,播放音效: ${音效} 显示信息: ${文字} 持续时间: ${Method} ${Time} 秒并 ${Wait/Don't Wait}
 *
 * @remark
 * '没有声音'的持续时间为5秒. 等待表示其他动作需要等待信息播放完毕后才能运行.
 *
 * @TC_CINEMATIC
 */
declare function TransmissionFromUnitWithNameBJ(toForce: force, whichUnit: unit, unitName: string, soundHandle: sound, message: string, timeType: number, timeVal: number, wait: boolean): void;

/**
 * 播送单位消息(指定单位-类型)  
 * 对 ${玩家组} 播送信息,发言单位: ${Player} 的 ${单位类型}  显示名字:  ${文字} 发言位置: ${指定点} 播放音效: ${音效} 显示信息: ${文字} 持续时间: ${Method} ${Time} 秒并 ${Wait/Don't Wait}
 *
 * @remark
 * '没有声音'的持续时间为5秒. 等待表示其他动作需要等待信息播放完毕后才能运行.
 *
 * @TC_CINEMATIC
 */
declare function TransmissionFromUnitTypeWithNameBJ(toForce: force, fromPlayer: player, unitId: number, unitName: string, loc: location, soundHandle: sound, message: string, timeType: number, timeVal: number, wait: boolean): void;

/**
 * 最后发言长度  
 * 最后发言长度
 *
 * @remark
 * 最后一次使用'电影 - 播送单位消息'动作的单位发言时间.
 *
 * @TC_CINEMATIC
 */
declare function GetLastTransmissionDurationBJ(): number;

/**
 * 字幕显示  
 * ${On/Off} 电影字幕显示功能
 *
 * @remark
 * 该功能和'游戏菜单-声音选项'中的字幕选项中有一项为开时即能够显示电影字幕.
 *
 * @TC_CINEMATIC
 */
declare function ForceCinematicSubtitlesBJ(flag: boolean): void;

/**
 * 电影模式(指定时间)  
 * ${On/Off} 电影模式对 ${玩家组} ,转换时间为 ${Time} 秒
 *
 * @TC_CINEMATIC
 */
declare function CinematicModeExBJ(cineMode: boolean, forForce: force, interfaceFadeTime: number): void;

/**
 * 电影模式  
 * ${On/Off} 电影模式对 ${玩家组}
 *
 * @TC_CINEMATIC
 */
declare function CinematicModeBJ(cineMode: boolean, forForce: force): void;

/**
 * 显示/隐藏 滤镜  
 * ${Show/Hide} 滤镜
 *
 * @TC_CINEMATIC
 */
declare function DisplayCineFilterBJ(flag: boolean): void;
declare function CinematicFadeCommonBJ(red: number, green: number, blue: number, duration: number, tex: string, startTrans: number, endTrans: number): void;
declare function FinishCinematicFadeBJ(): void;
declare function FinishCinematicFadeAfterBJ(duration: number): void;
declare function ContinueCinematicFadeBJ(): void;
declare function ContinueCinematicFadeAfterBJ(duration: number, red: number, green: number, blue: number, trans: number, tex: string): void;
declare function AbortCinematicFadeBJ(): void;

/**
 * 淡入淡出滤镜  
 * ${Fade Type} 使用 ${Duration} 秒时间,使用图片: ${Texture} 颜色值:(${Red}%, ${Green}%, ${Blue}%) 透明度: ${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_CINEMATIC
 */
declare function CinematicFadeBJ(fadetype: number, duration: number, tex: string, red: number, green: number, blue: number, trans: number): void;

/**
 * 高级滤镜  
 * 持续时间: ${Duration} 秒,混合方式: ${Blending Method} 使用图片: ${Texture} 开始颜色值:(${Red}%, ${Green}%, ${Blue}%) 透明度: ${Transparency}% ,结束颜色值:(${Red}%, ${Green}%, ${Blue}%) 透明度:${Transparency}%
 *
 * @remark
 * 颜色格式为(红,绿,蓝). 透明度100%是不可见的.
 *
 * @TC_CINEMATIC
 */
declare function CinematicFilterGenericBJ(duration: number, bmode: blendmode, tex: string, red0: number, green0: number, blue0: number, trans0: number, red1: number, green1: number, blue1: number, trans1: number): void;

/**
 * 营救单位  
 * 营救 ${单位} ,改变所属为 ${Player} 并 ${Change/Retain Color}
 *
 * @TC_UNIT
 */
declare function RescueUnitBJ(whichUnit: unit, rescuer: player, changeColor: boolean): void;
declare function TriggerActionUnitRescuedBJ(): void;
declare function TryInitRescuableTriggersBJ(): void;

/**
 * 设置营救颜色(单位)  
 * 设置单位 ${Change/Retain Color} 当被营救时
 *
 * @remark
 * 默认情况单位被营救时会改变颜色. 不影响已经被营救的单位.
 *
 * @TC_UNIT
 */
declare function SetRescueUnitColorChangeBJ(changeColor: boolean): void;

/**
 * 设置营救颜色(建筑)  
 * 设置建筑 ${Change/Retain Color} 当被营救时
 *
 * @remark
 * 默认建筑被营救时不会改变颜色. 不影响已经被营救的建筑.
 *
 * @TC_UNIT
 */
declare function SetRescueBuildingColorChangeBJ(changeColor: boolean): void;
declare function MakeUnitRescuableToForceBJEnum(): void;

/**
 * 设置可否营救(对玩家组)  
 * 设置 ${单位} ${Rescuable/Unrescuable} 对 ${玩家组}
 *
 * @TC_UNIT
 */
declare function MakeUnitRescuableToForceBJ(whichUnit: unit, isRescuable: boolean, whichForce: force): void;
declare function InitRescuableBehaviorBJ(): void;

/**
 * 设置科技等级  
 * 设置 ${科技} 的等级为 ${Level} 对 ${Player}
 *
 * @remark
 * 科技等级不能倒退.
 *
 * @TC_PLAYER
 */
declare function SetPlayerTechResearchedSwap(techid: number, levels: number, whichPlayer: player): void;

/**
 * 设置最大科技等级  
 * 设置 ${科技} 的等级为 ${Level} 对 ${Player}
 *
 * @remark
 * 科技等级不能倒退.
 *
 * @TC_PLAYER
 */
declare function SetPlayerTechMaxAllowedSwap(techid: number, maximum: number, whichPlayer: player): void;

/**
 * 限制英雄数量  
 * 限制英雄数量为 ${Limit} 对 ${Player}
 *
 * @remark
 * -1为无限制,0为不能生产.
 *
 * @TC_PLAYER
 */
declare function SetPlayerMaxHeroesAllowed(maximum: number, whichPlayer: player): void;

/**
 * 当前科技等级  
 * ${科技} 的当前等级对 ${Player}
 *
 * @TC_PLAYER
 */
declare function GetPlayerTechCountSimple(techid: number, whichPlayer: player): number;

/**
 * 最大科技等级  
 * ${科技} 的最大等级对 ${Player}
 *
 * @TC_PLAYER
 */
declare function GetPlayerTechMaxAllowedSwap(techid: number, whichPlayer: player): number;

/**
 * 允许/禁用 技能  
 * ${Enable/Disable} ${技能} 对 ${Player}
 *
 * @remark
 * 设置玩家能否使用该技能.
 *
 * @TC_PLAYER
 */
declare function SetPlayerAbilityAvailableBJ(avail: boolean, abilid: number, whichPlayer: player): void;

/**
 * 设置战役背景  
 * 设置战役背景为 ${Campaign}
 *
 * @TC_GAME
 */
declare function SetCampaignMenuRaceBJ(campaignNumber: number): void;

/**
 * 允许/禁止 关卡  
 * ${Enable/Disable} ${Mission}
 *
 * @TC_GAME
 */
declare function SetMissionAvailableBJ(available: boolean, missionIndex: number): void;

/**
 * 允许/禁止 战役  
 * ${Enable/Disable}  ${Campaign}
 *
 * @TC_GAME
 */
declare function SetCampaignAvailableBJ(available: boolean, campaignNumber: number): void;

/**
 * 允许/禁止 开场电影  
 * ${Enable/Disable} ${Cinematic}
 *
 * @TC_GAME
 */
declare function SetCinematicAvailableBJ(available: boolean, cinematicIndex: number): void;

/**
 * 创建游戏缓存  
 * 创建游戏缓存,使用文件名: ${Filename}
 *
 * @TC_GAMECACHE
 */
declare function InitGameCacheBJ(campaignFile: string): gamecache;

/**
 * 本地保存游戏缓存  
 * 保存 ${Game Cache} 到本地硬盘
 *
 * @remark
 * 只对单机游戏有效,保存缓存数据到本地硬盘,主要用来实现战役关卡间的数据传递.
 *
 * @TC_GAMECACHE
 */
declare function SaveGameCacheBJ(cache: gamecache): boolean;

/**
 * 最后创建的游戏缓存  
 * 最后创建的游戏缓存
 *
 * @remark
 * 最后一个由'游戏缓存 - 创建缓存'动作创建的缓存.
 *
 * @TC_LAST
 */
declare function GetLastCreatedGameCacheBJ(): gamecache;

/**
 * <1.24> 新建哈希表  
 * 创建一个新的哈希表
 *
 * @remark
 * 您可以使用哈希表来储存临时数据
 *
 * @TC_HASHTABLE
 */
declare function InitHashtableBJ(): hashtable;

/**
 * 最后创建的哈希表  
 * 最后创建的哈希表
 *
 * @remark
 * 能得到通过 '哈希表 - 新建哈希表' 最后一次创建的哈希表
 *
 * @TC_LAST
 */
declare function GetLastCreatedHashtableBJ(): hashtable;

/**
 * 记录实数  
 * 记录 ${实数} ,使用名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function StoreRealBJ(value: number, key: string, missionKey: string, cache: gamecache): void;

/**
 * 记录整数  
 * 记录 ${整数} ,使用名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function StoreIntegerBJ(value: number, key: string, missionKey: string, cache: gamecache): void;

/**
 * 记录布尔值  
 * 记录 ${布尔值} ,使用名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function StoreBooleanBJ(value: boolean, key: string, missionKey: string, cache: gamecache): void;

/**
 * 记录字符串  
 * 记录 ${字符串} ,使用名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function StoreStringBJ(value: string, key: string, missionKey: string, cache: gamecache): boolean;

/**
 * 记录单位  
 * 记录 ${单位} ,使用名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 使用'游戏缓存 - 读取单位'来读取该数值. 名称和类别名不能包含空格.
 *
 * @TC_GAMECACHE
 */
declare function StoreUnitBJ(whichUnit: unit, key: string, missionKey: string, cache: gamecache): boolean;

/**
 * <1.24> 保存实数  
 * 保存实数 ${Value} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable} 之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取实数' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveRealBJ(value: number, key: number, missionKey: number, table: hashtable): void;

/**
 * <1.24> 保存整数  
 * 保存整数 ${Value} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable} 之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取整数' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveIntegerBJ(value: number, key: number, missionKey: number, table: hashtable): void;

/**
 * <1.24> 保存布尔  
 * 保存布尔 ${Value} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable} 之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取布尔' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveBooleanBJ(value: boolean, key: number, missionKey: number, table: hashtable): void;

/**
 * <1.24> 保存字符串  
 * 保存字符串 ${Value} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取字符串' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveStringBJ(value: string, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存玩家  
 * 保存玩家 ${Player} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取玩家' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SavePlayerHandleBJ(whichPlayer: player, key: number, missionKey: number, table: hashtable): boolean;
declare function SaveWidgetHandleBJ(whichWidget: widget, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存可破坏物  
 * 保存可破坏物 ${Destructable} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取可破坏物' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveDestructableHandleBJ(whichDestructable: destructable, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存物品  
 * 保存物品 ${Item} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取物品' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveItemHandleBJ(whichItem: item, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存单位  
 * 保存单位 ${Unit} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取单位' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveUnitHandleBJ(whichUnit: unit, key: number, missionKey: number, table: hashtable): boolean;
declare function SaveAbilityHandleBJ(whichAbility: ability, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存计时器  
 * 保存计时器 ${Timer} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取计时器' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTimerHandleBJ(whichTimer: timer, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存触发器  
 * 保存触发器 ${Trigger} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取触发器' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTriggerHandleBJ(whichTrigger: trigger, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存触发条件  
 * 保存触发条件 ${Triggercondition} 在子索引 ${Value} of ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取触发条件' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTriggerConditionHandleBJ(whichTriggercondition: triggercondition, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存触发动作  
 * 保存触发动作 ${Triggeraction} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取触发动作' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTriggerActionHandleBJ(whichTriggeraction: triggeraction, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存触发事件  
 * 保存触发事件 ${Event} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取触发事件' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTriggerEventHandleBJ(whichEvent: event, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存玩家组  
 * 保存玩家组 ${Force} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取玩家组' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveForceHandleBJ(whichForce: force, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存单位组  
 * 保存单位组${Group} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取单位组' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveGroupHandleBJ(whichGroup: group, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存点  
 * 保存点 ${Location} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取点' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveLocationHandleBJ(whichLocation: location, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存区域(矩型)  
 * 保存区域(矩型) ${Rect} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取区域(矩型)' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveRectHandleBJ(whichRect: rect, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存布尔表达式  
 * 保存布尔表达式 ${Boolexpr} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取布尔表达式' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveBooleanExprHandleBJ(whichBoolexpr: boolexpr | (() => boolean) | null, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存音效  
 * 保存音效 ${Sound} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取音效' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveSoundHandleBJ(whichSound: sound, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存特效  
 * 保存特效${Effect} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取特效' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveEffectHandleBJ(whichEffect: effect, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存单位池  
 * 保存单位池 ${Unitpool} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取单位池' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveUnitPoolHandleBJ(whichUnitpool: unitpool, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存物品池  
 * 保存物品池 ${Itempool} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取物品池' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveItemPoolHandleBJ(whichItempool: itempool, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存任务  
 * 保存任务 ${Quest} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取任务' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveQuestHandleBJ(whichQuest: quest, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存任务要求  
 * 保存任务要求 ${Questitem} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取任务要求' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveQuestItemHandleBJ(whichQuestitem: questitem, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存失败条件  
 * 保存失败条件 ${Defeatcondition} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取失败条件' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveDefeatConditionHandleBJ(whichDefeatcondition: defeatcondition, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存计时器窗口  
 * 保存计时器窗口 ${Timerdialog} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取计时器窗口' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTimerDialogHandleBJ(whichTimerdialog: timerdialog, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存排行榜  
 * 保存排行榜 ${Leaderboard} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取排行榜' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveLeaderboardHandleBJ(whichLeaderboard: leaderboard, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存多面板  
 * 保存多面板 ${Multiboard} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取多面板' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveMultiboardHandleBJ(whichMultiboard: multiboard, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存多面板项目  
 * 保存多面板项目 ${Multiboarditem} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取多面板项目' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveMultiboardItemHandleBJ(whichMultiboarditem: multiboarditem, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存可追踪物  
 * 保存可追踪物 ${Trackable} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取可追踪物' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTrackableHandleBJ(whichTrackable: trackable, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存对话框  
 * 保存对话框 ${Dialog} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取对话框' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveDialogHandleBJ(whichDialog: dialog, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存对话框按钮  
 * 保存对话框按钮 ${Button} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取对话框按钮' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveButtonHandleBJ(whichButton: button, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存漂浮文字  
 * 保存漂浮文字 ${Texttag} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取漂浮文字' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveTextTagHandleBJ(whichTexttag: texttag, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存闪电效果  
 * 保存闪电效果 ${Lightning} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取闪电效果' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveLightningHandleBJ(whichLightning: lightning, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存图像  
 * 保存图像 ${Image} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取图像' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveImageHandleBJ(whichImage: image, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存地面纹理变化  
 * 保存地面纹理变化 ${Ubersplat} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取地面纹理变化' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveUbersplatHandleBJ(whichUbersplat: ubersplat, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存区域(不规则)  
 * 保存区域(不规则) ${Region} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取区域(不规则)' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveRegionHandleBJ(whichRegion: region, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存迷雾状态  
 * 保存迷雾状态 ${Fogstate} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取迷雾状态' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveFogStateHandleBJ(whichFogState: fogstate, key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 保存可见度修正器  
 * 保存可见度修正器 ${Fogmodifier} 在子索引 ${Value} 主索引 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 使用 '哈希表 - 从哈希表提取可见度修正器' 可以取出保存的值
 *
 * @TC_HASHTABLE
 */
declare function SaveFogModifierHandleBJ(whichFogModifier: fogmodifier, key: number, missionKey: number, table: hashtable): boolean;
declare function SaveAgentHandleBJ(whichAgent: agent, key: number, missionKey: number, table: hashtable): boolean;
declare function SaveHashtableHandleBJ(whichHashtable: hashtable, key: number, missionKey: number, table: hashtable): boolean;

/**
 * 缓存读取实数  
 * 从游戏缓存读取实数,名称: ${文字} 类别: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function GetStoredRealBJ(key: string, missionKey: string, cache: gamecache): number;

/**
 * 缓存读取整数  
 * 从游戏缓存读取整数,名称: ${文字} 类别: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function GetStoredIntegerBJ(key: string, missionKey: string, cache: gamecache): number;

/**
 * 读取布尔值  
 * 从游戏缓存读取布尔值,名称: ${文字} 类别: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function GetStoredBooleanBJ(key: string, missionKey: string, cache: gamecache): boolean;

/**
 * 读取字符串  
 * 从游戏缓存读取字符串,名称: ${文字} 类别: ${Category} 缓存: ${Game Cache}
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function GetStoredStringBJ(key: string, missionKey: string, cache: gamecache): string;

/**
 * <1.24> 从哈希表提取实数  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取实数
 *
 * @remark
 * 如果不存在则返回0.00
 *
 * @TC_HASHTABLE
 */
declare function LoadRealBJ(key: number, missionKey: number, table: hashtable): number;

/**
 * <1.24> 从哈希表提取整数  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取整数
 *
 * @remark
 * 如果不存在则返回0
 *
 * @TC_HASHTABLE
 */
declare function LoadIntegerBJ(key: number, missionKey: number, table: hashtable): number;

/**
 * <1.24> 从哈希表提取布尔  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取布尔
 *
 * @remark
 * 如果不存在则返回False
 *
 * @TC_HASHTABLE
 */
declare function LoadBooleanBJ(key: number, missionKey: number, table: hashtable): boolean;

/**
 * <1.24> 从哈希表提取字符串  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取字符串
 *
 * @remark
 * 如果不存在则返回空字符串
 *
 * @TC_HASHTABLE
 */
declare function LoadStringBJ(key: number, missionKey: number, table: hashtable): string;

/**
 * <1.24> 从哈希表提取玩家  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取玩家
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadPlayerHandleBJ(key: number, missionKey: number, table: hashtable): player;
declare function LoadWidgetHandleBJ(key: number, missionKey: number, table: hashtable): widget;

/**
 * <1.24> 从哈希表提取可破坏物  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取可破坏物
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadDestructableHandleBJ(key: number, missionKey: number, table: hashtable): destructable;

/**
 * <1.24> 从哈希表提取物品  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取物品
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadItemHandleBJ(key: number, missionKey: number, table: hashtable): item;

/**
 * <1.24> 从哈希表提取单位  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取单位
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadUnitHandleBJ(key: number, missionKey: number, table: hashtable): unit;
declare function LoadAbilityHandleBJ(key: number, missionKey: number, table: hashtable): ability;

/**
 * <1.24> 从哈希表提取计时器  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取计时器
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTimerHandleBJ(key: number, missionKey: number, table: hashtable): timer;

/**
 * <1.24> 从哈希表提取触发器  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取触发器
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTriggerHandleBJ(key: number, missionKey: number, table: hashtable): trigger;

/**
 * <1.24> 从哈希表提取触发条件  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取触发条件
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTriggerConditionHandleBJ(key: number, missionKey: number, table: hashtable): triggercondition;

/**
 * <1.24> 从哈希表提取触发动作  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取触发动作
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTriggerActionHandleBJ(key: number, missionKey: number, table: hashtable): triggeraction;

/**
 * <1.24> 从哈希表提取触发事件  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取触发事件
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTriggerEventHandleBJ(key: number, missionKey: number, table: hashtable): event;

/**
 * <1.24> 从哈希表提取玩家组  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取玩家组
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadForceHandleBJ(key: number, missionKey: number, table: hashtable): force;

/**
 * <1.24> 从哈希表提取单位组  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取单位组
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadGroupHandleBJ(key: number, missionKey: number, table: hashtable): group;

/**
 * <1.24> 从哈希表提取点  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取点
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadLocationHandleBJ(key: number, missionKey: number, table: hashtable): location;

/**
 * <1.24> 从哈希表提取区域(矩型)  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取区域(矩型)
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadRectHandleBJ(key: number, missionKey: number, table: hashtable): rect;

/**
 * <1.24> 从哈希表提取布尔表达式  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取布尔表达式
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadBooleanExprHandleBJ(key: number, missionKey: number, table: hashtable): boolexpr;

/**
 * <1.24> 从哈希表提取音效  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取音效
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadSoundHandleBJ(key: number, missionKey: number, table: hashtable): sound;

/**
 * <1.24> 从哈希表提取特效  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取特效
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadEffectHandleBJ(key: number, missionKey: number, table: hashtable): effect;

/**
 * <1.24> 从哈希表提取单位池  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取单位池
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadUnitPoolHandleBJ(key: number, missionKey: number, table: hashtable): unitpool;

/**
 * <1.24> 从哈希表提取物品池  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取物品池
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadItemPoolHandleBJ(key: number, missionKey: number, table: hashtable): itempool;

/**
 * <1.24> 从哈希表提取任务  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取任务
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadQuestHandleBJ(key: number, missionKey: number, table: hashtable): quest;

/**
 * <1.24> 从哈希表提取任务要求  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取任务要求
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadQuestItemHandleBJ(key: number, missionKey: number, table: hashtable): questitem;

/**
 * <1.24> 从哈希表提取失败条件  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取失败条件
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadDefeatConditionHandleBJ(key: number, missionKey: number, table: hashtable): defeatcondition;

/**
 * <1.24> 从哈希表提取计时器窗口  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取计时器窗口
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTimerDialogHandleBJ(key: number, missionKey: number, table: hashtable): timerdialog;

/**
 * <1.24> 从哈希表提取排行榜  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取排行榜
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadLeaderboardHandleBJ(key: number, missionKey: number, table: hashtable): leaderboard;

/**
 * <1.24> 从哈希表提取多面板  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取多面板
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadMultiboardHandleBJ(key: number, missionKey: number, table: hashtable): multiboard;

/**
 * <1.24> 从哈希表提取多面板项目  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取多面板项目
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadMultiboardItemHandleBJ(key: number, missionKey: number, table: hashtable): multiboarditem;

/**
 * <1.24> 从哈希表提取可追踪物  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取可追踪物
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTrackableHandleBJ(key: number, missionKey: number, table: hashtable): trackable;

/**
 * <1.24> 从哈希表提取对话框  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取对话框
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadDialogHandleBJ(key: number, missionKey: number, table: hashtable): dialog;

/**
 * <1.24> 从哈希表提取对话框按钮  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取对话框按钮
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadButtonHandleBJ(key: number, missionKey: number, table: hashtable): button;

/**
 * <1.24> 从哈希表提取漂浮文字  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取漂浮文字
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadTextTagHandleBJ(key: number, missionKey: number, table: hashtable): texttag;

/**
 * <1.24> 从哈希表提取闪电效果  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取闪电效果
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadLightningHandleBJ(key: number, missionKey: number, table: hashtable): lightning;

/**
 * <1.24> 从哈希表提取图象  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取图象
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadImageHandleBJ(key: number, missionKey: number, table: hashtable): image;

/**
 * <1.24> 从哈希表提取地面纹理变化  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取地面纹理变化
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadUbersplatHandleBJ(key: number, missionKey: number, table: hashtable): ubersplat;

/**
 * <1.24> 从哈希表提取区域(不规则)  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取区域(不规则)
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadRegionHandleBJ(key: number, missionKey: number, table: hashtable): region;

/**
 * <1.24> 从哈希表提取迷雾状态  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取迷雾状态
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadFogStateHandleBJ(key: number, missionKey: number, table: hashtable): fogstate;

/**
 * <1.24> 从哈希表提取可见度修正器  
 * 在子索引 ${Value} 主索引 ${Value} 的 ${Hashtable} 内提取可见度修正器
 *
 * @remark
 * 如果不存在则返回空
 *
 * @TC_HASHTABLE
 */
declare function LoadFogModifierHandleBJ(key: number, missionKey: number, table: hashtable): fogmodifier;
declare function LoadHashtableHandleBJ(key: number, missionKey: number, table: hashtable): hashtable;

/**
 * 读取单位(面向角度)  
 * 从缓存读取单位, 名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache} ,所属玩家: ${Player} 创建点: ${点} 面向角度: ${Angle}
 *
 * @remark
 * 使用'最后读取的单位'来获取该单位. 如果不存在该缓存数据,则'最后读取的单位'将被设为null.
 *
 * @TC_GAMECACHE
 */
declare function RestoreUnitLocFacingAngleBJ(key: string, missionKey: string, cache: gamecache, forWhichPlayer: player, loc: location, facing: number): unit;

/**
 * 读取单位(面向点)  
 * 从缓存读取单位, 名称: ${文字} 类别名: ${Category} 缓存: ${Game Cache} ,所属玩家: ${Player} 创建点: ${点} 面向: ${指定点}
 *
 * @remark
 * 使用'最后读取的单位'来获取该单位. 如果不存在该缓存数据,则'最后读取的单位'将被设为null.
 *
 * @TC_GAMECACHE
 */
declare function RestoreUnitLocFacingPointBJ(key: string, missionKey: string, cache: gamecache, forWhichPlayer: player, loc: location, lookAt: location): unit;

/**
 * 最后读取的单位  
 * 最后读取的单位
 *
 * @remark
 * 最后一个使用'游戏缓存 - 读取单位'动作创建的单位.
 *
 * @TC_LAST
 */
declare function GetLastRestoredUnitBJ(): unit;

/**
 * 删除缓存  
 * 删除 ${GameCache}
 *
 * @remark
 * 删除并清空该缓存的所有数据.
 *
 * @TC_GAMECACHE
 */
declare function FlushGameCacheBJ(cache: gamecache): void;

/**
 * 删除类别  
 * 删除类别 ${Category} 在缓存 ${GameCache} 中
 *
 * @remark
 * 原版UI，英文的语序的关系，为了使UI读起来更流畅，添加了一层封装，但这对中文来说就是画蛇添足了
 *
 * @TC_YDHIDE
 */
declare function FlushStoredMissionBJ(missionKey: string, cache: gamecache): void;

/**
 * <1.24> 清空哈希表  
 * <1.24> 清空 ${Hashtable}
 *
 * @remark
 * 清空哈希表所有数据
 *
 * @TC_HASHTABLE
 */
declare function FlushParentHashtableBJ(table: hashtable): void;

/**
 * <1.24> 清空哈希表主索引  
 * <1.24> 清空 ${Value} 位于 ${Hashtable}  之内
 *
 * @remark
 * 清空哈希表主索引下的所有数据
 *
 * @TC_HASHTABLE
 */
declare function FlushChildHashtableBJ(missionKey: number, table: hashtable): void;

/**
 * 缓存项存在  
 * 名称为 ${文字} 的 ${Type} 类缓存项被保存在类别: ${Category} 缓存: ${Game Cache}
 *
 * @TC_GAMECACHE
 */
declare function HaveStoredValue(key: string, valueType: number, missionKey: string, cache: gamecache): boolean;

/**
 * <1.24> 哈希项存在  
 * 子索引为 ${Value} 的 ${Type} 类数据被保存在主索引为 ${Value} 的 ${Hashtable} 中
 *
 * @TC_HASHTABLE
 */
declare function HaveSavedValue(key: number, valueType: number, missionKey: number, table: hashtable): boolean;

/**
 * 显示/隐藏 自定义战役按钮  
 * ${Show/Hide} 自定义战役按钮 #${Number}
 *
 * @TC_GAME
 */
declare function ShowCustomCampaignButton(show: boolean, whichButton: number): void;

/**
 * 自定义战役按钮可见  
 * 自定义战役按钮# ${Number} 可见
 *
 * @TC_GAME
 */
declare function IsCustomCampaignButtonVisibile(whichButton: number): boolean;

/**
 * 读取进度  
 * 读取游戏进度 ${Filename} (${Show/Skip} 计分屏)
 *
 * @TC_GAME
 */
declare function LoadGameBJ(loadFileName: string, doScoreScreen: boolean): void;

/**
 * 保存并切换关卡  
 * 保存游戏进度为: ${Filename} 并切换到关卡: ${Filename} (${Show/Skip} 计分屏)
 *
 * @TC_GAME
 */
declare function SaveAndChangeLevelBJ(saveFileName: string, newLevel: string, doScoreScreen: boolean): void;

/**
 * 保存并读取进度  
 * 保存游戏进度为: ${Filename} 并读取进度: ${Filename} (${Show/Skip} 计分屏)
 *
 * @TC_GAME
 */
declare function SaveAndLoadGameBJ(saveFileName: string, loadFileName: string, doScoreScreen: boolean): void;

/**
 * 重命名存档文件夹  
 * 更改 ${源文件夹} 的名字为 ${目标文件夹}
 *
 * @TC_GAME
 */
declare function RenameSaveDirectoryBJ(sourceDirName: string, destDirName: string): boolean;

/**
 * 删除存档文件夹  
 * 删除 ${文件夹}
 *
 * @remark
 * 文件夹内的内容都会被删除.
 *
 * @TC_GAME
 */
declare function RemoveSaveDirectoryBJ(sourceDirName: string): boolean;

/**
 * 复制存档文件  
 * 复制 ${源文件} 并保存为 ${目标文件}
 *
 * @remark
 * 该动作只在响应'保存/读取进度'时有效,每个事件中最多能用16次.
 *
 * @TC_GAME
 */
declare function CopySaveGameBJ(sourceSaveName: string, destSaveName: string): boolean;
declare function GetPlayerStartLocationX(whichPlayer: player): number;
declare function GetPlayerStartLocationY(whichPlayer: player): number;

/**
 * 玩家开始位置  
 * ${Player} 的游戏开始位置
 *
 * @remark
 * 会创建点.
 *
 * @TC_PLAYER
 */
declare function GetPlayerStartLocationLoc(whichPlayer: player): location;

/**
 * 矩形区域中心  
 * ${矩形区域} 的中心点
 *
 * @remark
 * 会创建点.
 *
 * @TC_NOTHING
 */
declare function GetRectCenter(whichRect: rect): location;
declare function IsPlayerSlotState(whichPlayer: player, whichState: playerslotstate): boolean;
declare function GetFadeFromSeconds(seconds: number): number;
declare function GetFadeFromSecondsAsReal(seconds: number): number;
declare function AdjustPlayerStateSimpleBJ(whichPlayer: player, whichPlayerState: playerstate, delta: number): void;

/**
 * 增加属性  
 * 增加 ${Value} ${Player} 的 ${Property}
 *
 * @remark
 * 使用负数来减少.
 *
 * @TC_PLAYER
 */
declare function AdjustPlayerStateBJ(delta: number, whichPlayer: player, whichPlayerState: playerstate): void;
declare function SetPlayerStateBJ(whichPlayer: player, whichPlayerState: playerstate, value: number): void;

/**
 * 开启/关闭 玩家参数  
 * 设置 ${Player Flag} ${On/Off} 对 ${Player}
 *
 * @remark
 * 开启玩家12的'给与奖励'表示杀死玩家12单位会获得金钱奖励.
 *
 * @TC_PLAYER
 */
declare function SetPlayerFlagBJ(whichPlayerFlag: playerstate, flag: boolean, whichPlayer: player): void;

/**
 * 设置税率  
 * 设置 ${Rate} %的 ${Resource} 所得税, ${Player} 交纳给 ${Player}
 *
 * @remark
 * 缴纳所得税所损失的资源可以通过'玩家得分'的'税务损失的黄金/木材'来获取. 所得税最高为100%. 且玩家1对玩家2和玩家3都交纳80%所得税.则玩家1采集黄金时将给玩家2 8黄金,玩家3 2黄金.
 *
 * @TC_PLAYER
 */
declare function SetPlayerTaxRateBJ(rate: number, whichResource: playerstate, sourcePlayer: player, otherPlayer: player): void;

/**
 * 玩家税率  
 * ${Resource} 所得税, ${Player} 交纳给 ${Player}
 *
 * @remark
 * 所得税取值范围0-100.
 *
 * @TC_PLAYER
 */
declare function GetPlayerTaxRateBJ(whichResource: playerstate, sourcePlayer: player, otherPlayer: player): number;

/**
 * 玩家参数开启  
 * ${Player Flag} 为允许,对 ${Player}
 *
 * @TC_PLAYER
 */
declare function IsPlayerFlagSetBJ(whichPlayerFlag: playerstate, whichPlayer: player): boolean;

/**
 * 增加黄金储量  
 * 增加 ${Quantity} 黄金储量给 ${金矿}
 *
 * @remark
 * 使用负数来减少黄金储量.
 *
 * @TC_NEUTRALBUILDING
 */
declare function AddResourceAmountBJ(delta: number, whichUnit: unit): void;

/**
 * 玩家ID  
 * ${Player} 的玩家ID
 *
 * @remark
 * 玩家ID取值1-16.
 *
 * @TC_PLAYER
 */
declare function GetConvertedPlayerId(whichPlayer: player): number;

/**
 * 转换玩家ID为玩家  
 * 玩家 ${Player Index}
 *
 * @remark
 * 玩家ID取值1-16.
 *
 * @TC_CONVERSION
 */
declare function ConvertedPlayer(convertedPlayerId: number): player;

/**
 * 宽度  
 * ${矩形区域} 的宽度
 *
 * @TC_RECT
 */
declare function GetRectWidthBJ(r: rect): number;

/**
 * 高度  
 * ${矩形区域} 的高度
 *
 * @TC_RECT
 */
declare function GetRectHeightBJ(r: rect): number;
declare function BlightGoldMineForPlayerBJ(goldMine: unit, whichPlayer: player): unit;

/**
 * 创建不死族金矿(立即)  
 * 将 ${金矿} 变为 ${Player} 的不死族金矿
 *
 * @remark
 * 金矿的储金量不会改变.
 *
 * @TC_NEUTRALBUILDING
 */
declare function BlightGoldMineForPlayer(goldMine: unit, whichPlayer: player): unit;

/**
 * 最后创建的不死族金矿  
 * 最后创建的不死族金矿
 *
 * @remark
 * 最后一个使用'中立建筑 - 创建不死族金矿'创建的不死族金矿.
 *
 * @TC_LAST
 */
declare function GetLastHauntedGoldMine(): unit;

/**
 * 点被荒芜地表覆盖  
 * ${指定点} 被荒芜地表覆盖
 *
 * @TC_ENVIRONMENT
 */
declare function IsPointBlightedBJ(where: location): boolean;
declare function SetPlayerColorBJEnum(): void;

/**
 * 改变玩家颜色  
 * 将 ${Player} 的玩家颜色改为 ${Color} ,并 ${Changing/Retaining color} 玩家单位颜色
 *
 * @TC_PLAYER
 */
declare function SetPlayerColorBJ(whichPlayer: player, color: playercolor, changeExisting: boolean): void;

/**
 * 设置单位可用性  
 * 设置 ${单位类型} ${Available/Unavailable} 对 ${Player}
 *
 * @remark
 * 设置玩家能否建造该单位.
 *
 * @TC_PLAYER
 */
declare function SetPlayerUnitAvailableBJ(unitId: number, allowed: boolean, whichPlayer: player): void;

/**
 * 锁定游戏速度  
 * 锁定游戏速度
 *
 * @remark
 * 使用该动作后无法改变游戏速度.
 *
 * @TC_GAME
 */
declare function LockGameSpeedBJ(): void;

/**
 * 解除锁定游戏速度  
 * 解除锁定游戏速度
 *
 * @remark
 * 解除'游戏 - 锁定游戏速度'对游戏速度的锁定.
 *
 * @TC_GAME
 */
declare function UnlockGameSpeedBJ(): void;
declare function IssueTargetOrderBJ(whichUnit: unit, order: string, targetWidget: widget): boolean;
declare function IssuePointOrderLocBJ(whichUnit: unit, order: string, whichLocation: location): boolean;

/**
 * 发布命令(指定可破坏物)  
 * 对 ${单位} 发布 ${Order} 命令到目标: ${可破坏物}
 *
 * @TC_UNIT
 */

/**
 * 发布命令(指定可破坏物)  
 * 对 ${单位} 发布 ${Order} 命令到目标: ${可破坏物}
 *
 * @TC_UNIT
 */
declare function IssueTargetDestructableOrder(whichUnit: unit, order: string, targetWidget: widget): boolean;

/**
 * 发布命令(指定物品)  
 * 对 ${单位} 发布 ${Order} 命令到目标: ${物品}
 *
 * @TC_UNIT
 */

/**
 * 发布命令(指定物品)  
 * 对 ${单位} 发布 ${Order} 命令到目标: ${物品}
 *
 * @TC_UNIT
 */
declare function IssueTargetItemOrder(whichUnit: unit, order: string, targetWidget: widget): boolean;
declare function IssueImmediateOrderBJ(whichUnit: unit, order: string): boolean;
declare function GroupTargetOrderBJ(whichGroup: group, order: string, targetWidget: widget): boolean;
declare function GroupPointOrderLocBJ(whichGroup: group, order: string, whichLocation: location): boolean;
declare function GroupImmediateOrderBJ(whichGroup: group, order: string): boolean;

/**
 * 发布命令(指定可破坏物)  
 * 对 ${单位组}发布 ${Order} 命令,目标: ${可破坏物}
 *
 * @remark
 * 最多只能对单位组中12个单位发布命令.
 *
 * @TC_UNITGROUP
 */
declare function GroupTargetDestructableOrder(whichGroup: group, order: string, targetWidget: widget): boolean;

/**
 * 发布命令(指定物品)  
 * 对 ${单位组}发布 ${Order} 命令,目标: ${物品}
 *
 * @remark
 * 最多只能对单位组中12个单位发布命令.
 *
 * @TC_UNITGROUP
 */
declare function GroupTargetItemOrder(whichGroup: group, order: string, targetWidget: widget): boolean;

/**
 * 死亡的可破坏物  
 * 死亡的可破坏物
 *
 * @remark
 * 响应'可破坏物死亡'事件.
 *
 * @TC_EVENTRESPONSE
 */
declare function GetDyingDestructable(): destructable;

/**
 * 设置集结点(指定点)  
 * 设置 ${单位} 的集结点到 ${指定点}
 *
 * @remark
 * 建议用发布'setrally'命令来实现该功能.
 *
 * @TC_UNIT
 */
declare function SetUnitRallyPoint(whichUnit: unit, targPos: location): void;

/**
 * 设置集结点(指定单位)  
 * 设置 ${单位} 的集结点到 ${单位}
 *
 * @remark
 * 建议用发布'setrally'命令来实现该功能.
 *
 * @TC_UNIT
 */
declare function SetUnitRallyUnit(whichUnit: unit, targUnit: unit): void;

/**
 * 设置集结点(指定物件)  
 * 设置 ${单位} 的集结点到 ${物件}
 *
 * @remark
 * 建议用发布'setrally'命令来实现该功能.
 *
 * @TC_UNIT
 */
declare function SetUnitRallyDestructable(whichUnit: unit, targDest: destructable): void;
declare function SaveDyingWidget(): void;

/**
 * 创建/删除荒芜地表(矩形区域)  
 * ${Create/Remove} 一块荒芜地表给 ${Player} 在 ${Region}
 *
 * @TC_ENVIRONMENT
 */
declare function SetBlightRectBJ(addBlight: boolean, whichPlayer: player, r: rect): void;

/**
 * 创建/删除荒芜地表(圆范围)(指定点)  
 * ${Create/Remove} 一块荒芜地表给 ${Player} 在圆心为 ${指定点} 半径为 ${Radius} 的圆范围
 *
 * @TC_ENVIRONMENT
 */
declare function SetBlightRadiusLocBJ(addBlight: boolean, whichPlayer: player, loc: location, radius: number): void;

/**
 * 技能名称  
 * ${技能} 的名称
 *
 * @TC_GAME
 */
declare function GetAbilityName(abilcode: number): string;

/**
 * 使用对战昼夜设置  
 * 使用对战昼夜设置
 *
 * @TC_MELEE
 */
declare function MeleeStartingVisibility(): void;

/**
 * 设置初始资源  
 * 设置初始资源
 *
 * @TC_MELEE
 */
declare function MeleeStartingResources(): void;
declare function ReducePlayerTechMaxAllowed(whichPlayer: player, techId: number, limit: number): void;

/**
 * 英雄限制  
 * 使用对战英雄设置
 *
 * @remark
 * 每个对战英雄只能建造1个. 最大英雄数量为3.
 *
 * @TC_MELEE
 */
declare function MeleeStartingHeroLimit(): void;
declare function MeleeTrainedUnitIsHeroBJFilter(): boolean;
declare function MeleeGrantItemsToHero(whichUnit: unit): void;
declare function MeleeGrantItemsToTrainedHero(): void;
declare function MeleeGrantItemsToHiredHero(): void;

/**
 * 英雄初始物品  
 * 给首发英雄一个回城卷轴
 *
 * @TC_MELEE
 */
declare function MeleeGrantHeroItems(): void;
declare function MeleeClearExcessUnit(): void;
declare function MeleeClearNearbyUnits(x: number, y: number, range: number): void;

/**
 * 删除多余单位  
 * 删除已使用开始点附近的中立生物
 *
 * @TC_MELEE
 */
declare function MeleeClearExcessUnits(): void;
declare function MeleeEnumFindNearestMine(): void;
declare function MeleeFindNearestMine(src: location, range: number): unit;
declare function MeleeRandomHeroLoc(p: player, id1: number, id2: number, id3: number, id4: number, loc: location): unit;
declare function MeleeGetProjectedLoc(src: location, targ: location, distance: number, deltaAngle: number): location;
declare function MeleeGetNearestValueWithin(val: number, minVal: number, maxVal: number): number;
declare function MeleeGetLocWithinRect(src: location, r: rect): location;
declare function MeleeStartingUnitsHuman(whichPlayer: player, startLoc: location, doHeroes: boolean, doCamera: boolean, doPreload: boolean): void;
declare function MeleeStartingUnitsOrc(whichPlayer: player, startLoc: location, doHeroes: boolean, doCamera: boolean, doPreload: boolean): void;
declare function MeleeStartingUnitsUndead(whichPlayer: player, startLoc: location, doHeroes: boolean, doCamera: boolean, doPreload: boolean): void;
declare function MeleeStartingUnitsNightElf(whichPlayer: player, startLoc: location, doHeroes: boolean, doCamera: boolean, doPreload: boolean): void;
declare function MeleeStartingUnitsUnknownRace(whichPlayer: player, startLoc: location, doHeroes: boolean, doCamera: boolean, doPreload: boolean): void;

/**
 * 创建初始单位  
 * 创建对战初始单位
 *
 * @TC_MELEE
 */
declare function MeleeStartingUnits(): void;

/**
 * 创建初始单位(指定玩家)  
 * 创建 ${Race} 的对战初始单位给 ${Player} 在 ${指定点} (${Include/Exclude} 英雄)
 *
 * @TC_MELEE
 */
declare function MeleeStartingUnitsForPlayer(whichRace: race, whichPlayer: player, loc: location, doHeroes: boolean): void;
declare function PickMeleeAI(num: player, s1: string, s2: string, s3: string): void;

/**
 * 运行AI  
 * 对电脑玩家运行对战AI脚本
 *
 * @remark
 * 动作运行之前玩家要有初始单位和资源.
 *
 * @TC_MELEE
 */
declare function MeleeStartingAI(): void;

/**
 * 锁定指定单位的警戒点  
 * 锁定 ${单位} 的警戒点
 *
 * @remark
 * 锁定并防止 AI 脚本改动单位警戒点.
 *
 * @TC_AI
 */
declare function LockGuardPosition(targ: unit): void;
declare function MeleePlayerIsOpponent(playerIndex: number, opponentIndex: number): boolean;
declare function MeleeGetAllyStructureCount(whichPlayer: player): number;
declare function MeleeGetAllyCount(whichPlayer: player): number;
declare function MeleeGetAllyKeyStructureCount(whichPlayer: player): number;
declare function MeleeDoDrawEnum(): void;
declare function MeleeDoVictoryEnum(): void;
declare function MeleeDoDefeat(whichPlayer: player): void;
declare function MeleeDoDefeatEnum(): void;
declare function MeleeDoLeave(whichPlayer: player): void;
declare function MeleeRemoveObservers(): void;
declare function MeleeCheckForVictors(): force;
declare function MeleeCheckForLosersAndVictors(): void;
declare function MeleeGetCrippledWarningMessage(whichPlayer: player): string;
declare function MeleeGetCrippledTimerMessage(whichPlayer: player): string;
declare function MeleeGetCrippledRevealedMessage(whichPlayer: player): string;
declare function MeleeExposePlayer(whichPlayer: player, expose: boolean): void;
declare function MeleeExposeAllPlayers(): void;
declare function MeleeCrippledPlayerTimeout(): void;
declare function MeleePlayerIsCrippled(whichPlayer: player): boolean;
declare function MeleeCheckForCrippledPlayers(): void;
declare function MeleeCheckLostUnit(lostUnit: unit): void;
declare function MeleeCheckAddedUnit(addedUnit: unit): void;
declare function MeleeTriggerActionConstructCancel(): void;
declare function MeleeTriggerActionUnitDeath(): void;
declare function MeleeTriggerActionUnitConstructionStart(): void;
declare function MeleeTriggerActionPlayerDefeated(): void;
declare function MeleeTriggerActionPlayerLeft(): void;
declare function MeleeTriggerActionAllianceChange(): void;
declare function MeleeTriggerTournamentFinishSoon(): void;
declare function MeleeWasUserPlayer(whichPlayer: player): boolean;
declare function MeleeTournamentFinishNowRuleA(multiplier: number): void;
declare function MeleeTriggerTournamentFinishNow(): void;

/**
 * 强制胜利/失败条件  
 * 强制使用对战胜利/失败条件
 *
 * @remark
 * 动作运行之前玩家要有单位.
 *
 * @TC_MELEE
 */
declare function MeleeInitVictoryDefeat(): void;
declare function CheckInitPlayerSlotAvailability(): void;
declare function SetPlayerSlotAvailable(whichPlayer: player, control: mapcontrol): void;
declare function TeamInitPlayerSlots(teamCount: number): void;
declare function MeleeInitPlayerSlots(): void;
declare function FFAInitPlayerSlots(): void;
declare function OneOnOneInitPlayerSlots(): void;
declare function InitGenericPlayerSlots(): void;
declare function SetDNCSoundsDawn(): void;
declare function SetDNCSoundsDusk(): void;
declare function SetDNCSoundsDay(): void;
declare function SetDNCSoundsNight(): void;
declare function InitDNCSounds(): void;
declare function InitBlizzardGlobals(): void;
declare function InitQueuedTriggers(): void;
declare function InitMapRects(): void;
declare function InitSummonableCaps(): void;
declare function UpdateStockAvailability(whichItem: item): void;
declare function UpdateEachStockBuildingEnum(): void;
declare function UpdateEachStockBuilding(iType: itemtype, iLevel: number): void;
declare function PerformStockUpdates(): void;
declare function StartStockUpdates(): void;
declare function RemovePurchasedItem(): void;
declare function InitNeutralBuildings(): void;
declare function MarkGameStarted(): void;
declare function DetectGameStarted(): void;
declare function InitBlizzard(): void;
declare function RandomDistReset(): void;
declare function RandomDistAddItem(inID: number, inChance: number): void;
declare function RandomDistChoose(): number;

/**
 * 单位掉落的物品  
 * 让 ${单位} 掉落一件 ${物品}
 *
 * @remark
 * 在单位所在区域(32x32)内的随机点创建一个物品，注意当单位站在不可通行路径旁边时，该物品可能掉落其中而无法拾取。
 *
 * @TC_NOTHING
 */
declare function UnitDropItem(inUnit: unit, inItemID: number): item;
declare function WidgetDropItem(inWidget: widget, inItemID: number): item;